{"version":3,"sources":["Mine.js","Timer.js","Board.js","Input.js","App.js","serviceWorker.js","index.js"],"names":["Mine","_ref","mine","mineSize","handleClick","handleRightClick","classes","concat","customClasses","labelText","state","MINE","REVEALED","isMine","minesNear","MARKED","react_default","a","createElement","className","onClick","onContextMenu","style","fontSize","height","lineHeight","width","Timer","_React$Component","props","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","start","Date","now","last","timePassed","requestID","inherits","createClass","key","value","_this2","window","requestAnimationFrame","updateTimer","_this3","setState","prevState","running","bind","cancelAnimationFrame","_this4","display","Math","floor","minutes","seconds","toLocaleString","minimumIntegerDigits","React","Component","Board","mines","timer","createRef","markedNum","i","push","j","HIDDEN","firstClick","mineX","mineY","mineRevealed","newMines","toConsumableArray","minesToTest","getMinesToTest","numMarkedNear","reduce","numMines","coords","forEach","temp","revealNear","map","row","element","square","objectSpread","clickX","clickY","possibilities","length","index","random","coord","splice","playing","GAME","IN_PROGRESS","updateState","LOSS","triggerLoss","validSquaresLeft","WIN","mineRow","mainContent","progress","button","status","message","_this5","_this$props","PAUSE","resume","max","round","INPUT","rowIndex","mineIndex","event","preventDefault","Timer_Timer","ref","rowTotal","Input","handleInputChange","handleSubmit","onSubmit","type","min","innerWidth","onChange","App","addEventListener","updates","inputType","defineProperty","target","Board_Board","Boolean","location","hostname","match","ReactDOM","render","src_App_0","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.8b0f8a35.chunk.js","sourcesContent":["import {MINE} from \"./constants.json\";\nimport PropTypes from \"prop-types\";\nimport React from \"react\";\n\n/**\n * Renders a mine based on its current status\n * @param {Object} props Contains a mine with its state (hidden, revealed, or marked), number of mines near it, a click handler + right click handler, and any potential custom classes\n * @returns {JSX} The rendered mine\n */\nexport function Mine({mine, mineSize, handleClick, handleRightClick}) {\n    // CSS classes of the mine\n    let classes = `mine ${mine.customClasses}`,\n        // text to show on the mine\n        labelText = null;\n    // if the mine is revealed\n    if (mine.state === MINE.REVEALED) {\n        // if it is a mine\n        if (mine.isMine === true) {\n            // style it as a mine\n            classes += \" mineLoss\";\n            // revealed mines show a X\n            labelText = \"X\";\n        } else {\n            // not a mine, style it based on number of nearby mines\n            classes += ` mineNum${mine.minesNear}`;\n            // don't show 0 on squares\n            if (mine.minesNear !== 0) {\n                // any other number of nearby mines should be displayed\n                labelText = mine.minesNear;\n            }\n        }\n    } else if (mine.state === MINE.MARKED) {\n        // marked squares show a !\n        labelText = \"!\";\n    }\n    return (\n        <div\n            // set the computed classes\n            className={classes}\n            // set up the click handler\n            onClick={handleClick}\n            // set up the right click handler\n            onContextMenu={handleRightClick}\n            style={{\n                \"fontSize\": mineSize,\n                \"height\": mineSize,\n                \"lineHeight\": mineSize,\n                \"width\": mineSize,\n            }}>\n            {/* show the computed text */}\n            <div className=\"label\">{labelText}</div>\n        </div>\n    );\n}\n\nMine.propTypes = {\n    \"handleClick\": PropTypes.func.isRequired,\n    \"handleRightClick\": PropTypes.func.isRequired,\n    \"mine\": PropTypes.object.isRequired,\n    \"mineSize\": PropTypes.number.isRequired,\n};\n","import PropTypes from \"prop-types\";\nimport React from \"react\";\n\nconst msPerSecond = 1000,\n    secondsPerMinute = 60;\n\nexport class Timer extends React.Component {\n    constructor(props) {\n        super(props);\n        // time to indicate when the timer was started\n        this.start = Date.now();\n        this.state = {\n            \"last\": Date.now(),\n            // amound of seconds that have passed since starting\n            \"timePassed\": 0,\n        };\n        // ask to update the timer (will occur every rendering until stopped)\n        this.requestID = null;\n    }\n\n    componentDidMount() {\n        this.requestID = window.requestAnimationFrame(() => {\n            this.updateTimer();\n        });\n    }\n\n    /**\n     * Update the number of seconds for the timer\n     */\n    updateTimer() {\n        this.setState((prevState) => ({\n            \"last\": Date.now(),\n            // update the number of seconds taht have passed since start\n            \"timePassed\": prevState.timePassed + (Date.now() - prevState.last),\n        }), () => {\n            // if we are still running\n            if (this.props.running === true) {\n                // update the timer again\n                window.requestAnimationFrame(this.updateTimer.bind(this));\n            }\n        });\n    }\n\n    componentWillUnmount() {\n        window.cancelAnimationFrame(this.requestID);\n    }\n\n    /**\n     * Continues the timer after it was stopped\n     */\n    resume() {\n        this.setState({\n            // update the last tick timing to prevent a large spike in time\n            \"last\": Date.now(),\n        }, () => {\n            // begin the updating loop for the timer\n            window.requestAnimationFrame(this.updateTimer.bind(this));\n        });\n    }\n\n    render() {\n        // only show timer if that is wanted\n        if (this.props.display === true) {\n            // number of seconds to display on timer\n            const timePassed = Math.floor(this.state.timePassed / msPerSecond),\n                // minutes part of the time\n                minutes = Math.floor(timePassed / secondsPerMinute),\n                // seconds part of the time\n                seconds = (timePassed % secondsPerMinute).toLocaleString([], {\n                    \"minimumIntegerDigits\": 2,\n                });\n            return (\n                <div>Time: {minutes}:{seconds}</div>\n            );\n        } else {\n            return null;\n        }\n    }\n}\n\nTimer.propTypes = {\n    \"display\": PropTypes.bool.isRequired,\n    \"running\": PropTypes.bool.isRequired,\n};\n","import {GAME, MINE} from \"./constants.json\";\nimport {Mine} from \"./Mine.js\";\nimport PropTypes from \"prop-types\";\nimport React from \"react\";\nimport {Timer} from \"./Timer.js\";\n\nconst pct = 100;\n\nexport class Board extends React.Component {\n    constructor(props) {\n        super(props);\n        // array to store the generated mines\n        let mines = [];\n        // ref for the timer so that we can resume it after pause\n        this.timer = React.createRef();\n        // number of marked squares\n        this.markedNum = 0;\n        // create HEIGHT inner arrays (rows)\n        for (let i = 0; i < props.height; ++i) {\n            mines.push([]);\n            // create WIDTH mine states per row (columns)\n            for (let j = 0; j < props.width; ++j) {\n                mines[i].push({\n                    // no custom CSS for mines currently\n                    \"customClasses\": \"\",\n                    // will be set later\n                    \"isMine\": false,\n                    // will be set later\n                    \"minesNear\": 0,\n                    // should start out hidden\n                    \"state\": MINE.HIDDEN,\n                });\n            }\n        }\n        // a click has not yet happened\n        this.firstClick = true;\n        this.state = {\n            // set mines to our (empty) 2-D array\n            mines,\n        };\n    }\n\n    /**\n     * Get all the adjacent coordinates of a specified mine\n     * @param {Number} mineX X-coordinate of the mine\n     * @param {Number} mineY Y-coordinate of the mine\n     * @returns {Array} A 2-D array containing adjacent coordinate pairs\n     */\n    getMinesToTest(mineX, mineY) {\n        // 3-line comments refer to the position of the mine to add\n        // where the x indicates the location of the specified\n        // and the * indicates the adjacent mine\n\n        // array to store nearby mines\n        let mines = [];\n        // if we aren't on the left edge\n        if (mineX > 0) {\n            // if we aren't at the top edge\n            if (mineY > 0) {\n                // - -\n                // - x -\n                // - - -\n                mines.push([mineX - 1, mineY - 1]);\n            }\n            // - - -\n            // x -\n            // - - -\n            mines.push([mineX - 1, mineY]);\n            // if we aren't on the bottom edge\n            if (mineY < this.props.height - 1) {\n                // - - -\n                // - x -\n                // - -\n                mines.push([mineX - 1, mineY + 1]);\n            }\n        }\n        // if we aren't at the top edge\n        if (mineY > 0) {\n            // - * -\n            // - x -\n            // - - -\n            mines.push([mineX, mineY - 1]);\n        }\n        // if we aren't on the bottom edge\n        if (mineY < this.props.height - 1) {\n            // - - -\n            // - x -\n            // - * -\n            mines.push([mineX, mineY + 1]);\n        }\n        // if we aren't on the right edge\n        if (mineX < this.props.width - 1) {\n            // if we aren't at the top edge\n            if (mineY > 0) {\n                // - - *\n                // - x -\n                // - - -\n                mines.push([mineX + 1, mineY - 1]);\n            }\n            // - - -\n            // - x *\n            // - - -\n            mines.push([mineX + 1, mineY]);\n            // if we aren't on the bottom edge\n            if (mineY < this.props.height - 1) {\n                // - - -\n                // - x -\n                // - - *\n                mines.push([mineX + 1, mineY + 1]);\n            }\n        }\n        // return our 2-D array of coordinates\n        return mines;\n    }\n\n    /**\n     * Reveal all mines near a target mine recursively\n     * @param {Array} mines 2-D array containing the status of all mines\n     * @param {Number} mineX X-coordiante of the initially revealed mine\n     * @param {Number} mineY Y-coordiante of the initially revealed mine\n     * @returns {Object} Contains mines, the updated 2-D mines array, and a mine indicating any if tripped, or null if not\n     */\n    revealNear(mines, mineX, mineY) {\n        let mineRevealed = false,\n            newMines = [...mines];\n        // get the mines that should be checked\n        const minesToTest = this.getMinesToTest(mineX, mineY),\n            // count up all the number of nearby marked squares\n            numMarkedNear = minesToTest.reduce((numMines, coords) => {\n                if (mines[coords[1]][coords[0]].state === MINE.MARKED) {\n                    return numMines + 1;\n                } else {\n                    return numMines;\n                }\n            }, 0);\n        // if there are as many marked nearby squares as there are nearby mines, begin the reveal\n        if (newMines[mineY][mineX].minesNear === numMarkedNear) {\n            minesToTest.forEach((coords) => {\n                let mine = newMines[coords[1]][coords[0]];\n                if (mine.state === MINE.MARKED && !mine.isMine) {\n                    mineRevealed = true;\n                    mine.customClasses = \"mineLossAutoClick\";\n                    mineRevealed = mine;\n                }\n            });\n            // for each mine to test\n            if (mineRevealed === false) {\n                minesToTest.forEach((coords) => {\n                    if (mineRevealed === false) {\n                        // get the mine associated with that coordiante\n                        let mine = mines[coords[1]][coords[0]];\n                        // if the mine is still hidden\n                        if (mine.state === MINE.HIDDEN) {\n                            // reveal it\n                            mine.state = MINE.REVEALED;\n                            // if we tripped a mine\n                            if (mine.isMine) {\n                                mineRevealed = coords;\n                                // indicate that the mine was autotripped\n                                mine.customClasses = \"mineLossAutoClick\";\n                            } else {\n                                // recursively call the reveal function, using the coordinates of the newly revealed mine\n                                const temp = this.revealNear(newMines, coords[0], coords[1]);\n                                // if we didn't trip any mines\n                                ({mineRevealed} = temp);\n                                if (mineRevealed === false) {\n                                    // update the state of the board\n                                    newMines = temp.mines;\n                                }\n                            }\n                        }\n                    }\n                }, this);\n            }\n        }\n        // return the mines and any tripped mine, if applicable\n        return {\n            mineRevealed,\n            mines,\n        };\n    }\n\n    /**\n     * Calculate how many non-mine squares are unrevealed\n     * @param {Array} mines 2-D array of mines to search through\n     * @returns {Number} The number of unrevealed non-mine squares\n     */\n    static validSquaresLeft(mines) {\n        // count up all the hidden non-mine squares remaining of all rows\n        return mines.reduce((numMines, mineRow) => numMines + mineRow.reduce((rowTotal, mine) => {\n            if (mine.state === MINE.HIDDEN && mine.isMine === false) {\n                return rowTotal + 1;\n            } else {\n                return rowTotal;\n            }\n        }, 0), 0);\n    }\n\n    triggerLoss() {\n        this.setState((prevState) => ({\n            // for each square on the board\n            \"mines\": prevState.mines.map((row) => row.map((element) => {\n                // shallow copy the square\n                let square = {...element};\n                if (square.isMine === false && square.state === MINE.MARKED) {\n                    square.customClasses += \" falseMark\";\n                }\n                // mark the clicked mine specially\n                if (square.state === MINE.HIDDEN) {\n                    // any untouched mines are grayed out\n                    square.customClasses += \" after\";\n                }\n                if (square.isMine === false || square.state === MINE.HIDDEN) {\n                    square.state = MINE.REVEALED;\n                }\n                return square;\n            })),\n        }));\n    }\n\n    // handler for when a mine is clicked\n    handleClick(clickX, clickY) {\n        let {mines} = this.state;\n        // if this is the first click\n        if (this.firstClick === true) {\n            // generate the mines to ensure a protected first click\n            this.setState((prevState) => {\n                // get all the coordinates\n                let possibilities = [];\n                for (let i = 0; i < prevState.mines.length; ++i) {\n                    for (let j = 0; j < prevState.mines[i].length; ++j) {\n                        // but don't add the clicked coordinate as a possible mine\n                        if (!(j === clickX && i === clickY)) {\n                            possibilities.push([j, i]);\n                        }\n                    }\n                }\n                // generate the desired number of mines\n                for (let i = 0; i < this.props.numMines; ++i) {\n                    // get a random index that isn't the clicked coordinate or already a mine\n                    const index = Math.floor(Math.random() * possibilities.length),\n                        // get the coordinates of that index\n                        coord = possibilities[index];\n                    // make sure we don't re-pick that for the next mine\n                    possibilities.splice(index, 1);\n                    // set that square to be a mine\n                    prevState.mines[coord[1]][coord[0]].isMine = true;\n                    // for each adjacent square\n                    this.getMinesToTest(coord[0], coord[1])\n                        .forEach((coords) => {\n                            // increment the amount of nearby mines that it has\n                            ++prevState.mines[coords[1]][coords[0]].minesNear;\n                        });\n                }\n                // set our mines\n                return {\n                    \"mines\": prevState.mines,\n                };\n            }, () => {\n                // click has already happened, don't repeat this\n                this.firstClick = false;\n                // do the revealing for that square\n                this.handleClick(clickX, clickY);\n            });\n        } else if (this.props.playing === GAME.IN_PROGRESS &&\n            this.state.mines[clickY][clickX].state !== MINE.MARKED) {\n            // if the game is going on and the mine isn't marked, perform a click\n            mines[clickY][clickX].state = MINE.REVEALED;\n            // if a mine was clicked\n            if (mines[clickY][clickX].isMine) {\n                this.props.updateState({\n                    // set the game to a losss\n                    \"playing\": GAME.LOSS,\n                });\n                // specially mark the clicked mine\n                mines[clickY][clickX].customClasses += \" mineLossClick\";\n                this.setState({\n                    // update the mines\n                    mines,\n                    // then trigger a loss\n                }, this.triggerLoss);\n            } else {\n                // wasn't a mine, reveal all nearby squares based on marked squares\n                let temp = this.revealNear(mines, clickX, clickY);\n                // if a mine got tripped\n                if (temp.mineRevealed === true) {\n                    this.props.updateState({\n                        \"playing\": GAME.LOSS,\n                    });\n                    this.triggerLoss();\n                } else if (Board.validSquaresLeft(temp.mines) === 0) {\n                    // if nothing is left, victory!\n                    this.props.updateState({\n                        \"playing\": GAME.WIN,\n                    });\n                    this.setState({\n                        // for each of the squares\n                        \"mines\": temp.mines.map((mineRow) => mineRow.map((element) => {\n                            let mine = element;\n                            // if it was a mine, mark it (but don't actually make it an X)\n                            if (mine.isMine === true) {\n                                mine.state = MINE.MARKED;\n                            }\n                            return mine;\n                        })),\n                    });\n                } else {\n                    // nothing got tripped, continue play with the revealed mine(s)\n                    this.setState({\n                        \"mines\": temp.mines,\n                    });\n                }\n            }\n        }\n    }\n\n    // handler for when a mine is right clicked\n    handleRightClick(clickX, clickY) {\n        if (this.props.playing === GAME.IN_PROGRESS) {\n            // get the mine that was clicked\n            const mine = this.state.mines[clickY][clickX];\n            // if it wasn't already revealed\n            if (mine.state !== MINE.REVEALED) {\n                this.setState((prevState) => {\n                    // if it was marked\n                    if (mine.state === MINE.MARKED) {\n                        // set it to be hidden (unmarked)\n                        prevState.mines[clickY][clickX].state = MINE.HIDDEN;\n                        // decrement the number of marked mines\n                        --this.markedNum;\n                    } else {\n                        // otherwise set it to be marked\n                        prevState.mines[clickY][clickX].state = MINE.MARKED;\n                        // and increment the number of marked mines\n                        ++this.markedNum;\n                    }\n                    return {\n                        // update the toggled mine\n                        \"mines\": prevState.mines,\n                    };\n                });\n            }\n        }\n    }\n\n    render() {\n        // get relevant info from props\n        const {width, height, numMines, playing} = this.props;\n        // number of squares revealed of total number of non-mines, as a percentage\n        let mainContent, progress;\n        if (this.firstClick === true) {\n            progress = 0;\n        } else {\n            progress = pct - (pct * Board.validSquaresLeft(this.state.mines) / ((height * width) - numMines));\n        }\n        if (playing === GAME.PAUSE) {\n            mainContent = (\n                // if the game is paused, show the pause screen\n                <div>\n                    Paused<br />\n                    {/* button that will resume the game */}\n                    <button onClick={() => {\n                        this.props.updateState({\n                            \"playing\": GAME.IN_PROGRESS,\n                        });\n                        this.timer.resume();\n                    }}>\n                        Resume\n                    </button>\n                </div>\n            );\n        } else {\n            let button, status, message, mineSize;\n            // while playing, show the blue and green progress bar\n            if (playing === GAME.IN_PROGRESS) {\n                status = (\n                    <div className=\"status\">\n                        {/* show the \"number of mines left\", or 0 if too many are flagged */}\n                        <div>Mines Left: {Math.max(this.props.numMines - this.markedNum, 0)}</div>\n                        <div>\n                            Progress:\n                            <div className=\"bar\">\n                                <div\n                                    // necessary styling for the green inner bar\n                                    className=\"innerBar\"\n                                    // make it be proportionally sized to the progress\n                                    style={{\"width\": `${progress}%`}}>\n                                    {/* display percent progress to the nearest tenth */}\n                                    {Math.round(10 * progress) / 10}%\n                                </div>\n                            </div>\n                        </div>\n                    </div>\n                );\n                button = (\n                    <button onClick={this.props.updateState.bind(this, {\n                        \"playing\": GAME.PAUSE,\n                    })}>Pause</button>\n                );\n            } else {\n                button = (\n                    <button onClick={this.props.updateState.bind(this, {\n                        \"playing\": GAME.INPUT,\n                    })}>Restart</button>\n                );\n            }\n            if (playing === GAME.WIN) {\n                message = <div className=\"status win\">Good job!</div>;\n            } else if (playing === GAME.LOSS) {\n                message = <div className=\"status\">You lost!</div>;\n            }\n            if (80 / this.props.width < 80 / this.props.height) {\n                mineSize = `${80 / this.props.width}vw`;\n            } else {\n                mineSize = `${80 / this.props.height}vh`;\n            }\n            mainContent = (\n                <div>\n                    {/* main board, dynamically adjust it to be in the middle of the screen */}\n                    <div className=\"board\">\n                        {/* generate the board of mines */}\n                        {this.state.mines.map((mineRow, rowIndex) => (\n                            // create a row for each row of mines\n                            <div className=\"row\" key={rowIndex}>\n                                {/* for each mine in the row */}\n                                {mineRow.map((mine, mineIndex) => (\n                                    // generate a mine\n                                    <Mine\n                                        key={mineIndex}\n                                        // pass it the current data of the mine\n                                        mine={mine}\n                                        // pass it the click handler\n                                        handleClick={() => {\n                                            this.handleClick(mineIndex, rowIndex);\n                                        }}\n                                        mineSize={mineSize}\n                                        // pass it the right click handler\n                                        handleRightClick={(event) => {\n                                            // make sure to prevent the default right click popup\n                                            event.preventDefault();\n                                            this.handleRightClick(mineIndex, rowIndex);\n                                        }} />\n                                ))}\n                            </div>\n                        ))}\n                    </div>\n                    {/* helpful info below the board */}\n                    {status}\n                    {message}\n                    {/* if the game ended, offer up a restart */}\n                    {button}\n                </div>\n            );\n        }\n        return (\n            <div>\n                {/* timer to show how long the game has been */}\n                < Timer\n                    // only running while game is playing\n                    running={playing === GAME.IN_PROGRESS}\n                    // don't show on pause screen\n                    display={playing !== GAME.PAUSE}\n                    ref={(ref) => {\n                        this.timer = ref;\n                    }} />\n                {mainContent}\n            </div >\n        );\n    }\n}\n\nBoard.propTypes = {\n    \"height\": PropTypes.number.isRequired,\n    \"numMines\": PropTypes.number.isRequired,\n    \"playing\": PropTypes.bool.isRequired,\n    \"updateState\": PropTypes.func.isRequired,\n    \"width\": PropTypes.number.isRequired,\n};\n","import PropTypes from \"prop-types\";\nimport React from \"react\";\n\n/**\n * Input form to get game settings\n * @param {Object} props Provides a handler for input change and submit, as well as the current width, height, and number of mines\n * @returns {Component} The rendered input form\n */\nexport function Input({handleInputChange, handleSubmit, height, numMines, width}) {\n    // const {handleInputChange, handleSubmit, height, numMines, width} = this.props;\n    return (\n        <form onSubmit={handleSubmit.bind(this)}>\n            {/* input for width of board */}\n            <label>Board width <input\n                // make it a numeric input\n                type=\"number\"\n                // need at least 1 wide board\n                min={1}\n                // don't make it too wide or weird wrapping happens\n                max={Math.floor(window.innerWidth / 6)}\n                // initially set to whatever the width was\n                value={width}\n                onChange={handleInputChange.bind(this, \"width\")} />\n            </label>\n            {/* input for height of board */}\n            <label>Board height <input\n                // make it a numeric input\n                type=\"number\"\n                // need at least 1 tall board\n                min={1}\n                // initially set to whatever the height was\n                value={height}\n                onChange={handleInputChange.bind(this, \"height\")}\n            />\n            </label>\n            {/* input for number of mines */}\n            <label>Number of mines <input\n                // make it a numeric input\n                type=\"number\"\n                // need at least 1 mine\n                min={1}\n                // must have at least 1 non-mine\n                max={(width * height) - 1}\n                // initially set to whatever the number of mines was\n                value={numMines}\n                onChange={handleInputChange.bind(this, \"numMines\")} />\n            </label>\n            {/* button to start playing */}\n            <input type=\"submit\" value=\"Play!\" />\n        </form>\n    );\n}\n\nInput.propTypes = {\n    \"handleInputChange\": PropTypes.func.isRequired,\n    \"handleSubmit\": PropTypes.func.isRequired,\n    \"height\": PropTypes.number.isRequired,\n    \"numMines\": PropTypes.number.isRequired,\n    \"width\": PropTypes.number.isRequired,\n};\n","import \"./App.css\";\nimport {Board} from \"./Board.js\";\nimport {GAME} from \"./constants.json\";\nimport {Input} from \"./Input.js\";\nimport React from \"react\";\n\nclass App extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            // start out in the input phase\n            \"height\": 15,\n            \"numMines\": 75,\n            \"playing\": GAME.INPUT,\n            \"width\": 30,\n        };\n    }\n\n    componentDidMount() {\n        // when the window loses focus\n        window.addEventListener(\"blur\", () => {\n            // if we were in a game, pause it\n            if (this.state.playing === GAME.IN_PROGRESS) {\n                this.setState({\n                    \"playing\": GAME.PAUSE,\n                });\n            }\n        });\n    }\n\n    updateState(updates) {\n        this.setState(updates);\n    }\n\n    handleSubmit(event) {\n        event.preventDefault();\n        this.setState({\n            \"playing\": GAME.IN_PROGRESS,\n        });\n    }\n\n    handleInputChange(inputType, event) {\n        this.setState({\n            [inputType]: event.target.value,\n        });\n    }\n\n    render() {\n        if (this.state.playing === GAME.INPUT) {\n            return (\n                <Input\n                    width={this.state.width}\n                    height={this.state.height}\n                    numMines={this.state.numMines}\n                    handleSubmit={this.handleSubmit.bind(this)}\n                    handleInputChange={this.handleInputChange.bind(this)} />\n            );\n        } else {\n            return (\n                <Board\n                    width={this.state.width}\n                    height={this.state.height}\n                    numMines={this.state.numMines}\n                    playing={this.state.playing}\n                    updateState={this.updateState.bind(this)} />\n            );\n        }\n    }\n}\n\nexport default App;\n","// this optional code is used to register a service worker.\n// register() is not called by default.\n\n// this lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// to learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n    window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n        /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n    if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n        // the URL constructor is available in all browsers that support SW.\n        const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n        if (publicUrl.origin !== window.location.origin) {\n            // our service worker won't work if PUBLIC_URL is on a different origin\n            // from what our page is served on. This might happen if a CDN is used to\n            // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n            return;\n        }\n\n        window.addEventListener(\"load\", () => {\n            const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n            if (isLocalhost) {\n                // this is running on localhost. Let's check if a service worker still exists or not.\n                checkValidServiceWorker(swUrl, config);\n\n                // add some additional logging to localhost, pointing developers to the\n                // service worker/PWA documentation.\n                navigator.serviceWorker.ready.then(() => {\n                    console.log(\n                        \"This web app is being served cache-first by a service \" +\n                        \"worker. To learn more, visit http://bit.ly/CRA-PWA\"\n                    );\n                });\n            } else {\n                // is not localhost. Just register service worker\n                registerValidSW(swUrl, config);\n            }\n        });\n    }\n}\n\nfunction registerValidSW(swUrl, config) {\n    navigator.serviceWorker\n        .register(swUrl)\n        .then(registration => {\n            registration.onupdatefound = () => {\n                const installingWorker = registration.installing;\n                if (installingWorker == null) {\n                    return;\n                }\n                installingWorker.onstatechange = () => {\n                    if (installingWorker.state === \"installed\") {\n                        if (navigator.serviceWorker.controller) {\n                            // at this point, the updated precached content has been fetched,\n                            // but the previous service worker will still serve the older\n                            // content until all client tabs are closed.\n                            console.log(\n                                \"New content is available and will be used when all \" +\n                                \"tabs for this page are closed. See http://bit.ly/CRA-PWA.\"\n                            );\n\n                            // execute callback\n                            if (config && config.onUpdate) {\n                                config.onUpdate(registration);\n                            }\n                        } else {\n                            // at this point, everything has been precached.\n                            // it's the perfect time to display a\n                            // \"Content is cached for offline use.\" message.\n                            console.log(\"Content is cached for offline use.\");\n\n                            // execute callback\n                            if (config && config.onSuccess) {\n                                config.onSuccess(registration);\n                            }\n                        }\n                    }\n                };\n            };\n        })\n        .catch(error => {\n            console.error(\"Error during service worker registration:\", error);\n        });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n    // check if the service worker can be found. If it can't reload the page.\n    fetch(swUrl)\n        .then(response => {\n            // ensure service worker exists, and that we really are getting a JS file.\n            const contentType = response.headers.get(\"content-type\");\n            if (\n                response.status === 404 ||\n                (contentType != null && contentType.indexOf(\"javascript\") === -1)\n            ) {\n                // no service worker found. Probably a different app. Reload the page.\n                navigator.serviceWorker.ready.then(registration => {\n                    registration.unregister().then(() => {\n                        window.location.reload();\n                    });\n                });\n            } else {\n                // service worker found. Proceed as normal.\n                registerValidSW(swUrl, config);\n            }\n        })\n        .catch(() => {\n            console.log(\"No internet connection found. App is running in offline mode.\");\n        });\n}\n\nexport function unregister() {\n    if (\"serviceWorker\" in navigator) {\n        navigator.serviceWorker.ready.then(registration => {\n            registration.unregister();\n        });\n    }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n// if you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}