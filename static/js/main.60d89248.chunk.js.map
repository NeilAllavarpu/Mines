{"version":3,"sources":["Mine.js","Timer.js","ScoreBoard.js","Board.js","Input.js","App.js","serviceWorker.js","index.js"],"names":["Mine","_ref","mine","mineSize","handleClick","handleRightClick","classes","concat","customClasses","labelText","state","MINE","REVEALED","isMine","minesNear","MARKED","react_default","a","createElement","className","onClick","onContextMenu","style","fontSize","height","lineHeight","width","Timer","_React$Component","props","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","start","Date","now","last","timePassed","requestID","inherits","createClass","key","value","_this2","window","requestAnimationFrame","updateTimer","_this3","setState","prevState","running","bind","cancelAnimationFrame","_this4","display","Math","floor","minutes","seconds","toLocaleString","minimumIntegerDigits","React","Component","ScoreBoard","apply","arguments","scores","localStorage","getItem","split","map","score","updateState","playing","GAME","INPUT","Board","mines","timer","createRef","markedNum","i","push","j","HIDDEN","firstClick","hasFinished","showHelp","mineX","mineY","minesToTest","getMinesToTest","numMarkedNear","reduce","numMines","coords","index","length","triggerLoss","mineRevealed","temp","revealNear","row","element","square","objectSpread","clickX","clickY","possibilities","random","coord","splice","forEach","IN_PROGRESS","LOSS","validSquaresLeft","WIN","parseFloat","console","log","getTime","sort","setItem","mineRow","mainContent","progress","button","status","message","_this$props","PAUSE","resume","max","round","rowIndex","mineIndex","event","preventDefault","ScoreBoard_ScoreBoard","Timer_Timer","ref","rowTotal","Input","handleInputChange","handleSubmit","onSubmit","type","min","innerWidth","name","onChange","App","addEventListener","updates","defineProperty","target","Board_Board","Boolean","location","hostname","match","ReactDOM","render","src_App_0","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.60d89248.chunk.js","sourcesContent":["import {MINE} from \"./constants.json\";\nimport PropTypes from \"prop-types\";\nimport React from \"react\";\n\n/**\n * Renders a mine based on its current status\n * @param {Object} props Contains a mine with its state (hidden, revealed, or marked), number of mines near it, a click handler + right click handler, and any potential custom classes\n * @returns {JSX} The rendered mine\n */\nexport function Mine({mine, mineSize, handleClick, handleRightClick}) {\n    // CSS classes of the mine\n    let classes = `mine ${mine.customClasses}`,\n        // text to show on the mine\n        labelText = null;\n    // if the mine is revealed\n    if (mine.state === MINE.REVEALED) {\n        // if it is a mine\n        if (mine.isMine === true) {\n            // style it as a mine\n            classes += \" mineLoss\";\n            // revealed mines show a X\n            labelText = \"X\";\n        } else {\n            // not a mine, style it based on number of nearby mines\n            classes += ` mineNum${mine.minesNear}`;\n            // don't show 0 on squares\n            if (mine.minesNear !== 0) {\n                // any other number of nearby mines should be displayed\n                labelText = mine.minesNear;\n            }\n        }\n    } else if (mine.state === MINE.MARKED) {\n        // marked squares show a !\n        labelText = \"!\";\n    }\n    return (\n        <div\n            // set the computed classes\n            className={classes}\n            // set up the click handler\n            onClick={handleClick}\n            // set up the right click handler\n            onContextMenu={handleRightClick}\n            style={{\n                \"fontSize\": mineSize,\n                \"height\": mineSize,\n                \"lineHeight\": mineSize,\n                \"width\": mineSize,\n            }}>\n            {/* show the computed text */}\n            <div className=\"label\">{labelText}</div>\n        </div>\n    );\n}\n\nMine.propTypes = {\n    \"handleClick\": PropTypes.func.isRequired,\n    \"handleRightClick\": PropTypes.func.isRequired,\n    \"mine\": PropTypes.object.isRequired,\n    \"mineSize\": PropTypes.number.isRequired,\n};\n","import PropTypes from \"prop-types\";\nimport React from \"react\";\n\nconst msPerSecond = 1000,\n    secondsPerMinute = 60;\n\nexport class Timer extends React.Component {\n    constructor(props) {\n        super(props);\n        // time to indicate when the timer was started\n        this.start = Date.now();\n        this.state = {\n            \"last\": Date.now(),\n            // amound of seconds that have passed since starting\n            \"timePassed\": 0,\n        };\n        // ask to update the timer (will occur every rendering until stopped)\n        this.requestID = null;\n    }\n\n    componentDidMount() {\n        this.requestID = window.requestAnimationFrame(() => {\n            this.updateTimer();\n        });\n    }\n\n    /**\n     * Update the number of seconds for the timer\n     */\n    updateTimer() {\n        this.setState((prevState) => ({\n            \"last\": Date.now(),\n            // update the number of seconds taht have passed since start\n            \"timePassed\": prevState.timePassed + (Date.now() - prevState.last),\n        }), () => {\n            // if we are still running\n            if (this.props.running === true) {\n                // update the timer again\n                window.requestAnimationFrame(this.updateTimer.bind(this));\n            }\n        });\n    }\n\n    componentWillUnmount() {\n        window.cancelAnimationFrame(this.requestID);\n    }\n\n    /**\n     * Continues the timer after it was stopped\n     */\n    resume() {\n        this.setState({\n            // update the last tick timing to prevent a large spike in time\n            \"last\": Date.now(),\n        }, () => {\n            // begin the updating loop for the timer\n            window.requestAnimationFrame(this.updateTimer.bind(this));\n        });\n    }\n\n    getTime() {\n        return this.state.timePassed / 1000;\n    }\n\n    render() {\n        // only show timer if that is wanted\n        if (this.props.display === true) {\n            // number of seconds to display on timer\n            const timePassed = Math.floor(this.state.timePassed / msPerSecond),\n                // minutes part of the time\n                minutes = Math.floor(timePassed / secondsPerMinute),\n                // seconds part of the time\n                seconds = (timePassed % secondsPerMinute).toLocaleString([], {\n                    \"minimumIntegerDigits\": 2,\n                });\n            return (\n                <div>Time: {minutes}:{seconds}</div>\n            );\n        } else {\n            return null;\n        }\n    }\n}\n\nTimer.propTypes = {\n    \"display\": PropTypes.bool.isRequired,\n    \"running\": PropTypes.bool.isRequired,\n};\n","import React from \"react\";\nimport {GAME} from \"./constants.json\";\n\nexport class ScoreBoard extends React.Component {\n    render() {\n        let scores = localStorage.getItem(\"scores\");\n        if (scores) {\n            scores = scores.split(\",\")\n            return (\n                <div>\n                    <h2>Fastest Times</h2>\n                    <ol>\n                        {scores.map((score) => (\n                            <li>\n                                {Math.floor(score / 60)}:{(score % 60).toLocaleString([], {\n                                    \"minimumIntegerDigits\": 2,\n                                })}\n                            </li>\n                        ))}\n                    </ol>\n                    <button onClick={this.props.updateState.bind(this, {\n                        \"playing\": GAME.INPUT,\n                    })}>Restart</button>\n                </div>\n            );\n        } else {\n            return (\n                <div>\n                    Play to get some times here!\n                </div>\n            );\n        }\n    }\n}\n","import {GAME, MINE} from \"./constants.json\";\nimport {Mine} from \"./Mine.js\";\nimport PropTypes from \"prop-types\";\nimport React from \"react\";\nimport {Timer} from \"./Timer.js\";\nimport {ScoreBoard} from \"./ScoreBoard.js\";\n\nconst pct = 100;\n\nexport class Board extends React.Component {\n    constructor(props) {\n        super(props);\n        // array to store the generated mines\n        let mines = [];\n        // ref for the timer so that we can resume it after pause\n        this.timer = React.createRef();\n        // number of marked squares\n        this.markedNum = 0;\n        // create HEIGHT inner arrays (rows)\n        for (let i = 0; i < props.height; ++i) {\n            mines.push([]);\n            // create WIDTH mine states per row (columns)\n            for (let j = 0; j < props.width; ++j) {\n                mines[i].push({\n                    // no custom CSS for mines currently\n                    \"customClasses\": \"\",\n                    // will be set later\n                    \"isMine\": false,\n                    // will be set later\n                    \"minesNear\": 0,\n                    // should start out hidden\n                    \"state\": MINE.HIDDEN,\n                });\n            }\n        }\n        // a click has not yet happened\n        this.firstClick = true;\n        this.state = {\n            // set mines to our (empty) 2-D array\n            mines,\n            \"hasFinished\": false,\n            \"showHelp\": false,\n        };\n    }\n\n    /**\n     * Get all the adjacent coordinates of a specified mine\n     * @param {Number} mineX X-coordinate of the mine\n     * @param {Number} mineY Y-coordinate of the mine\n     * @returns {Array} A 2-D array containing adjacent coordinate pairs\n     */\n    getMinesToTest(mineX, mineY) {\n        // 3-line comments refer to the position of the mine to add\n        // where the x indicates the location of the specified\n        // and the * indicates the adjacent mine\n\n        // array to store nearby mines\n        let mines = [];\n        // if we aren't on the left edge\n        if (mineX > 0) {\n            // if we aren't at the top edge\n            if (mineY > 0) {\n                // - -\n                // - x -\n                // - - -\n                mines.push([mineX - 1, mineY - 1]);\n            }\n            // - - -\n            // x -\n            // - - -\n            mines.push([mineX - 1, mineY]);\n            // if we aren't on the bottom edge\n            if (mineY < this.props.height - 1) {\n                // - - -\n                // - x -\n                // - -\n                mines.push([mineX - 1, mineY + 1]);\n            }\n        }\n        // if we aren't at the top edge\n        if (mineY > 0) {\n            // - * -\n            // - x -\n            // - - -\n            mines.push([mineX, mineY - 1]);\n        }\n        // if we aren't on the bottom edge\n        if (mineY < this.props.height - 1) {\n            // - - -\n            // - x -\n            // - * -\n            mines.push([mineX, mineY + 1]);\n        }\n        // if we aren't on the right edge\n        if (mineX < this.props.width - 1) {\n            // if we aren't at the top edge\n            if (mineY > 0) {\n                // - - *\n                // - x -\n                // - - -\n                mines.push([mineX + 1, mineY - 1]);\n            }\n            // - - -\n            // - x *\n            // - - -\n            mines.push([mineX + 1, mineY]);\n            // if we aren't on the bottom edge\n            if (mineY < this.props.height - 1) {\n                // - - -\n                // - x -\n                // - - *\n                mines.push([mineX + 1, mineY + 1]);\n            }\n        }\n        // return our 2-D array of coordinates\n        return mines;\n    }\n\n    /**\n     * Reveal all mines near a target mine recursively\n     * @param {Array} mines 2-D array containing the status of all mines\n     * @param {Number} mineX X-coordiante of the initially revealed mine\n     * @param {Number} mineY Y-coordiante of the initially revealed mine\n     * @returns {Object} Contains mines, the updated 2-D mines array, and a mine indicating any if tripped, or null if not\n     */\n    revealNear(mines, mineX, mineY) {\n        // get the mines that should be checked\n        const minesToTest = this.getMinesToTest(mineX, mineY),\n            // count up all the number of nearby marked squares\n            numMarkedNear = minesToTest.reduce((numMines, coords) => {\n                if (mines[coords[1]][coords[0]].state === MINE.MARKED) {\n                    return numMines + 1;\n                } else {\n                    return numMines;\n                }\n            }, 0);\n        // if there are as many marked nearby squares as there are nearby mines, begin the reveal\n        if (mines[mineY][mineX].minesNear === numMarkedNear) {\n            for (let index = 0; index < minesToTest.length; index++) {\n                const coords = minesToTest[index];\n                let mine = mines[coords[1]][coords[0]];\n                if (mine.state === MINE.MARKED && mine.isMine === false) {\n                    this.triggerLoss();\n                    return {\n                        \"mineRevealed\": true,\n                        mines,\n                    };\n                } else {\n                    // get the mine associated with that coordiante\n                    let mine = mines[coords[1]][coords[0]];\n                    // if the mine is still hidden\n                    if (mine.state === MINE.HIDDEN) {\n                        // if we tripped a mine\n                        if (mine.isMine) {\n                            // end it all\n                            this.triggerLoss();\n                            return {\n                                \"mineRevealed\": true,\n                                mines,\n                            };\n                        } else {\n                            // reveal it\n                            mine.state = MINE.REVEALED;\n                            // recursively call the reveal function, using the coordinates of the newly revealed mine\n                            const temp = this.revealNear(mines, coords[0], coords[1]);\n                            // if we didn't trip any mines\n                            if (temp.mineRevealed === false) {\n                                // update the state of the board\n                                mines = temp.mines;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        // return the mines and any tripped mine, if applicable\n        return {\n            \"mineRevealed\": false,\n            mines,\n        };\n    }\n\n    /**\n     * Calculate how many non-mine squares are unrevealed\n     * @param {Array} mines 2-D array of mines to search through\n     * @returns {Number} The number of unrevealed non-mine squares\n     */\n    static validSquaresLeft(mines) {\n        // count up all the hidden non-mine squares remaining of all rows\n        return mines.reduce((numMines, mineRow) => numMines + mineRow.reduce((rowTotal, mine) => {\n            if (mine.state === MINE.HIDDEN && mine.isMine === false) {\n                return rowTotal + 1;\n            } else {\n                return rowTotal;\n            }\n        }, 0), 0);\n    }\n\n    triggerLoss() {\n        this.setState((prevState) => ({\n            // for each square on the board\n            \"mines\": prevState.mines.map((row) => row.map((element) => {\n                // shallow copy the square\n                let square = {...element};\n                // notify of any false marks\n                if (square.isMine === false && square.state === MINE.MARKED) {\n                    square.customClasses += \" falseMark\";\n                }\n                // any untouched mines are grayed out\n                if (square.state === MINE.HIDDEN) {\n                    square.customClasses += \" after\";\n                }\n                if (!(square.isMine === true && square.state === MINE.MARKED)) {\n                    square.state = MINE.REVEALED;\n                }\n                return square;\n            })),\n        }));\n    }\n\n    // handler for when a mine is clicked\n    handleClick(clickX, clickY) {\n        let {mines} = this.state;\n        // if this is the first click\n        if (this.firstClick === true) {\n            // generate the mines to ensure a protected first click\n            this.setState((prevState) => {\n                // get all the coordinates\n                let possibilities = [];\n                for (let i = 0; i < prevState.mines.length; ++i) {\n                    for (let j = 0; j < prevState.mines[i].length; ++j) {\n                        // but don't add the clicked coordinate as a possible mine\n                        if (!(j === clickX && i === clickY)) {\n                            possibilities.push([j, i]);\n                        }\n                    }\n                }\n                // generate the desired number of mines\n                for (let i = 0; i < this.props.numMines; ++i) {\n                    // get a random index that isn't the clicked coordinate or already a mine\n                    const index = Math.floor(Math.random() * possibilities.length),\n                        // get the coordinates of that index\n                        coord = possibilities[index];\n                    // make sure we don't re-pick that for the next mine\n                    possibilities.splice(index, 1);\n                    // set that square to be a mine\n                    prevState.mines[coord[1]][coord[0]].isMine = true;\n                    // for each adjacent square\n                    this.getMinesToTest(coord[0], coord[1])\n                        .forEach((coords) => {\n                            // increment the amount of nearby mines that it has\n                            ++prevState.mines[coords[1]][coords[0]].minesNear;\n                        });\n                }\n                // set our mines\n                return {\n                    \"mines\": prevState.mines,\n                };\n            }, () => {\n                // click has already happened, don't repeat this\n                this.firstClick = false;\n                // do the revealing for that square\n                this.handleClick(clickX, clickY);\n            });\n        } else if (this.props.playing === GAME.IN_PROGRESS &&\n            this.state.mines[clickY][clickX].state !== MINE.MARKED) {\n            // if the game is going on and the mine isn't marked, perform a click\n            mines[clickY][clickX].state = MINE.REVEALED;\n            // if a mine was clicked\n            if (mines[clickY][clickX].isMine) {\n                this.props.updateState({\n                    // set the game to a losss\n                    \"playing\": GAME.LOSS,\n                });\n                // specially mark the clicked mine\n                mines[clickY][clickX].customClasses += \" mineLossClick\";\n                this.setState({\n                    // update the mines\n                    mines,\n                    // then trigger a loss\n                }, this.triggerLoss);\n            } else {\n                // wasn't a mine, reveal all nearby squares based on marked squares\n                let temp = this.revealNear(mines, clickX, clickY);\n                // if a mine got tripped\n                if (temp.mineRevealed === true) {\n                    this.props.updateState({\n                        \"playing\": GAME.LOSS,\n                    });\n                    this.triggerLoss();\n                } else if (Board.validSquaresLeft(temp.mines) === 0) {\n                    // if nothing is left, victory!\n                    this.props.updateState({\n                        \"playing\": GAME.WIN,\n                    });\n                    let scores = localStorage.getItem(\"scores\").split(\",\");\n                    scores = scores.map((score) => parseFloat(score));\n                    console.log(scores)\n                    scores.push(this.timer.getTime());\n                    scores.sort();\n                    scores.splice(10);\n                    localStorage.setItem(\"scores\", scores);\n                    console.log(localStorage.getItem(\"scores\").split(\",\"))\n                    this.setState({\n                        // for each of the squares\n                        \"mines\": temp.mines.map((mineRow) => mineRow.map((element) => {\n                            let mine = element;\n                            // if it was a mine, mark it (but don't actually make it an X)\n                            if (mine.isMine === true) {\n                                mine.state = MINE.MARKED;\n                            }\n                            return mine;\n                        })),\n                        \"hasFinished\": true,\n                    });\n                } else {\n                    // nothing got tripped, continue play with the revealed mine(s)\n                    this.setState({\n                        \"mines\": temp.mines,\n                    });\n                }\n            }\n        }\n    }\n\n    // handler for when a mine is right clicked\n    handleRightClick(clickX, clickY) {\n        if (this.props.playing === GAME.IN_PROGRESS) {\n            // get the mine that was clicked\n            const mine = this.state.mines[clickY][clickX];\n            // if it wasn't already revealed\n            if (mine.state !== MINE.REVEALED) {\n                this.setState((prevState) => {\n                    // if it was marked\n                    if (mine.state === MINE.MARKED) {\n                        // set it to be hidden (unmarked)\n                        prevState.mines[clickY][clickX].state = MINE.HIDDEN;\n                        // decrement the number of marked mines\n                        --this.markedNum;\n                    } else {\n                        // otherwise set it to be marked\n                        prevState.mines[clickY][clickX].state = MINE.MARKED;\n                        // and increment the number of marked mines\n                        ++this.markedNum;\n                    }\n                    return {\n                        // update the toggled mine\n                        \"mines\": prevState.mines,\n                    };\n                });\n            }\n        }\n    }\n\n    render() {\n        // get relevant info from props\n        const {width, height, numMines, playing} = this.props;\n        // number of squares revealed of total number of non-mines, as a percentage\n        let mainContent, progress;\n        if (this.firstClick === true) {\n            progress = 0;\n        } else {\n            progress = pct - (pct * Board.validSquaresLeft(this.state.mines) / ((height * width) - numMines));\n        }\n        if (playing === GAME.PAUSE) {\n            mainContent = (\n                // if the game is paused, show the pause screen\n                <div>\n                    Paused<br />\n                    {/* button that will resume the game */}\n                    <button onClick={() => {\n                        this.props.updateState({\n                            \"playing\": GAME.IN_PROGRESS,\n                        });\n                        if (!this.firstClick) {\n                            this.timer.resume();\n                        }\n                    }}>\n                        Resume\n                    </button>\n                </div>\n            );\n        } else {\n            let button, status, message, mineSize;\n            // while playing, show the blue and green progress bar\n            if (playing === GAME.IN_PROGRESS) {\n                status = (\n                    <div className=\"status\">\n                        {/* show the \"number of mines left\", or 0 if too many are flagged */}\n                        <div>Mines Left: {Math.max(this.props.numMines - this.markedNum, 0)}</div>\n                        <div>\n                            Progress:\n                            <div className=\"bar\">\n                                <div\n                                    // necessary styling for the green inner bar\n                                    className=\"innerBar\"\n                                    // make it be proportionally sized to the progress\n                                    style={{\"width\": `${progress}%`}}>\n                                    {/* display percent progress to the nearest tenth */}\n                                    {Math.round(10 * progress) / 10}%\n                                </div>\n                            </div>\n                        </div>\n                    </div>\n                );\n                button = (\n                    <button onClick={this.props.updateState.bind(this, {\n                        \"playing\": GAME.PAUSE,\n                    })}>Pause</button>\n                );\n            } else {\n                button = (\n                    <button onClick={this.props.updateState.bind(this, {\n                        \"playing\": GAME.INPUT,\n                    })}>Restart</button>\n                );\n            }\n            if (playing === GAME.WIN) {\n                message = <div className=\"status win\">Good job!</div>;\n            } else if (playing === GAME.LOSS) {\n                message = <div className=\"status\">You lost!</div>;\n            }\n            if (80 / this.props.width < 80 / this.props.height) {\n                mineSize = `${80 / this.props.width}vw`;\n            } else {\n                mineSize = `${80 / this.props.height}vh`;\n            }\n            mainContent = (\n                <div>\n                    {/* main board, dynamically adjust it to be in the middle of the screen */}\n                    <div className=\"board\">\n                        {/* generate the board of mines */}\n                        {this.state.mines.map((mineRow, rowIndex) => (\n                            // create a row for each row of mines\n                            <div className=\"row\" key={rowIndex}>\n                                {/* for each mine in the row */}\n                                {mineRow.map((mine, mineIndex) => (\n                                    // generate a mine\n                                    <Mine\n                                        key={mineIndex}\n                                        // pass it the current data of the mine\n                                        mine={mine}\n                                        // pass it the click handler\n                                        handleClick={() => {\n                                            this.handleClick(mineIndex, rowIndex);\n                                        }}\n                                        mineSize={mineSize}\n                                        // pass it the right click handler\n                                        handleRightClick={(event) => {\n                                            // make sure to prevent the default right click popup\n                                            event.preventDefault();\n                                            this.handleRightClick(mineIndex, rowIndex);\n                                        }} />\n                                ))}\n                            </div>\n                        ))}\n                    </div>\n                    {/* helpful info below the board */}\n                    {status}\n                    {message}\n                    {/* if the game ended, offer up a restart */}\n                    {button}\n                    <br />\n                    <button\n                        onClick={() => {\n                            this.setState((prevState) => ({\n                                \"showHelp\": !prevState.showHelp,\n                            }));\n                        }}>\n                        Toggle Help\n                    </button>\n                    {this.state.showHelp &&\n                        <p className=\"help\">\n                            At the start screen, enter your desired width, height, and number of mines for your game. The board cannot be wider than the screen, and the number of mines must be less than the total number of squares; play will not commence until these requirements are met. Default is a 30x15 board with 75 mines.\n                            <br />\n                            <br />\n                            Clicking on untested squares reveals them. Right-clicking on a square flags it as a mine as a `!`, but is not required.\n                            <br />\n                            <br />\n                            If a mine is revealed, the game will end immediately as a loss, all mines are revealed, and the triggered mine will flash blue and red.\n                            <br />\n                            <br />\n                            Clicking on a square with the same number of flagged squares adjacent to it as number of mines adjacent to it (ex: any square with no adjacent mines and no adjacent flagged squares, or a `2` with 2 adjacent flagged sqaures) automatically reveals all non-flagged adjacent squares. If a mine is revealed at an adjacent square (due to a misflagged square), the misflagged square flashes blue and red and the game follows the same loss conditions as above. If any of the revealed squares satisfies the same condition, that square will reveal adjacent squares by the same logic. This occurs repeatedly until no squares that are revealed that satisfy this condition.\n                            <br />\n                            <br />\n                            When all non-mine squares have been revealed, the game ends in victory.\n                            <br />\n                            <br />\n                            A timer above the board indicates how long the game has lasted; this stops immediately on victory or loss. A counter below the board indicates how many mines are left based on the number of flagged squares (number of total mines - number of flagged squares), but never dips below 0. This is simply based on flagged squares, and does not indicate whether or not those flags are correct. Below this counter is a progress bar indicating how many of the non-mine squares have been revealed.\n                    </p>}\n                </div>\n            );\n        }\n        if (this.state.hasFinished) {\n            mainContent = <ScoreBoard updateState={this.props.updateState.bind(this)} />;\n        }\n        return (\n            <div>\n                {/* timer to show how long the game has been */}\n                {!this.firstClick && <Timer\n                    // only running while game is playing\n                    running={playing === GAME.IN_PROGRESS}\n                    // don't show on pause screen\n                    display={playing !== GAME.PAUSE && playing !== GAME.WIN}\n                    ref={(ref) => {\n                        this.timer = ref;\n                    }} />}\n                {mainContent}\n            </div >\n        );\n    }\n}\n\nBoard.propTypes = {\n    \"height\": PropTypes.number.isRequired,\n    \"numMines\": PropTypes.number.isRequired,\n    \"playing\": PropTypes.number.isRequired,\n    \"updateState\": PropTypes.func.isRequired,\n    \"width\": PropTypes.number.isRequired,\n};\n","import PropTypes from \"prop-types\";\nimport React from \"react\";\n\n/**\n * Input form to get game settings\n * @param {Object} props Provides a handler for input change and submit, as well as the current width, height, and number of mines\n * @returns {Component} The rendered input form\n */\nexport function Input({handleInputChange, handleSubmit, height, numMines, width}) {\n    // const {handleInputChange, handleSubmit, height, numMines, width} = this.props;\n    return (\n        <form onSubmit={handleSubmit.bind(this)}>\n            {/* input for width of board */}\n            <label>Board width <input\n                // make it a numeric input\n                type=\"number\"\n                // need at least 1 wide board\n                min={1}\n                // don't make it too wide or weird wrapping happens\n                max={Math.floor(window.innerWidth / 6)}\n                // initially set to whatever the width was\n                value={width}\n                name=\"width\"\n                onChange={handleInputChange.bind(this)} />\n            </label>\n            {/* input for height of board */}\n            <label>Board height <input\n                // make it a numeric input\n                type=\"number\"\n                // need at least 1 tall board\n                min={1}\n                // initially set to whatever the height was\n                value={height}\n                name=\"height\"\n                onChange={handleInputChange.bind(this)}\n            />\n            </label>\n            {/* input for number of mines */}\n            <label>Number of mines <input\n                // make it a numeric input\n                type=\"number\"\n                // need at least 1 mine\n                min={1}\n                // must have at least 1 non-mine\n                max={(width * height) - 1}\n                // initially set to whatever the number of mines was\n                value={numMines}\n                name=\"numMines\"\n                onChange={handleInputChange.bind(this)} />\n            </label>\n            {/* button to start playing */}\n            <input type=\"submit\" value=\"Play!\" />\n        </form>\n    );\n}\n\nInput.propTypes = {\n    \"handleInputChange\": PropTypes.func.isRequired,\n    \"handleSubmit\": PropTypes.func.isRequired,\n    \"height\": PropTypes.number.isRequired,\n    \"numMines\": PropTypes.number.isRequired,\n    \"width\": PropTypes.number.isRequired,\n};\n","import \"./App.css\";\nimport {Board} from \"./Board.js\";\nimport {GAME} from \"./constants.json\";\nimport {Input} from \"./Input.js\";\nimport React from \"react\";\n\nclass App extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            // start out in the input phase\n            \"height\": 15,\n            \"numMines\": 75,\n            \"playing\": GAME.INPUT,\n            \"width\": 30,\n        };\n    }\n\n    componentDidMount() {\n        // when the window loses focus\n        window.addEventListener(\"blur\", () => {\n            // if we were in a game, pause it\n            if (this.state.playing === GAME.IN_PROGRESS) {\n                this.setState({\n                    \"playing\": GAME.PAUSE,\n                });\n            }\n        });\n    }\n\n    updateState(updates) {\n        this.setState(updates);\n    }\n\n    handleSubmit(event) {\n        event.preventDefault();\n        this.setState({\n            \"playing\": GAME.IN_PROGRESS,\n        });\n    }\n\n    handleInputChange(event) {\n        this.setState({\n            [event.target.name]: event.target.value,\n        });\n    }\n\n    render() {\n        if (this.state.playing === GAME.INPUT) {\n            return (\n                <Input\n                    width={this.state.width}\n                    height={this.state.height}\n                    numMines={this.state.numMines}\n                    handleSubmit={this.handleSubmit.bind(this)}\n                    handleInputChange={this.handleInputChange.bind(this)} />\n            );\n        } else {\n            return (\n                <Board\n                    width={this.state.width}\n                    height={this.state.height}\n                    numMines={this.state.numMines}\n                    playing={this.state.playing}\n                    updateState={this.updateState.bind(this)} />\n            );\n        }\n    }\n}\n\nexport default App;\n","// this optional code is used to register a service worker.\n// register() is not called by default.\n\n// this lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// to learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n    window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n        /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n    if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n        // the URL constructor is available in all browsers that support SW.\n        const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n        if (publicUrl.origin !== window.location.origin) {\n            // our service worker won't work if PUBLIC_URL is on a different origin\n            // from what our page is served on. This might happen if a CDN is used to\n            // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n            return;\n        }\n\n        window.addEventListener(\"load\", () => {\n            const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n            if (isLocalhost) {\n                // this is running on localhost. Let's check if a service worker still exists or not.\n                checkValidServiceWorker(swUrl, config);\n\n                // add some additional logging to localhost, pointing developers to the\n                // service worker/PWA documentation.\n                navigator.serviceWorker.ready.then(() => {\n                    console.log(\n                        \"This web app is being served cache-first by a service \" +\n                        \"worker. To learn more, visit http://bit.ly/CRA-PWA\"\n                    );\n                });\n            } else {\n                // is not localhost. Just register service worker\n                registerValidSW(swUrl, config);\n            }\n        });\n    }\n}\n\nfunction registerValidSW(swUrl, config) {\n    navigator.serviceWorker\n        .register(swUrl)\n        .then(registration => {\n            registration.onupdatefound = () => {\n                const installingWorker = registration.installing;\n                if (installingWorker == null) {\n                    return;\n                }\n                installingWorker.onstatechange = () => {\n                    if (installingWorker.state === \"installed\") {\n                        if (navigator.serviceWorker.controller) {\n                            // at this point, the updated precached content has been fetched,\n                            // but the previous service worker will still serve the older\n                            // content until all client tabs are closed.\n                            console.log(\n                                \"New content is available and will be used when all \" +\n                                \"tabs for this page are closed. See http://bit.ly/CRA-PWA.\"\n                            );\n\n                            // execute callback\n                            if (config && config.onUpdate) {\n                                config.onUpdate(registration);\n                            }\n                        } else {\n                            // at this point, everything has been precached.\n                            // it's the perfect time to display a\n                            // \"Content is cached for offline use.\" message.\n                            console.log(\"Content is cached for offline use.\");\n\n                            // execute callback\n                            if (config && config.onSuccess) {\n                                config.onSuccess(registration);\n                            }\n                        }\n                    }\n                };\n            };\n        })\n        .catch(error => {\n            console.error(\"Error during service worker registration:\", error);\n        });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n    // check if the service worker can be found. If it can't reload the page.\n    fetch(swUrl)\n        .then(response => {\n            // ensure service worker exists, and that we really are getting a JS file.\n            const contentType = response.headers.get(\"content-type\");\n            if (\n                response.status === 404 ||\n                (contentType != null && contentType.indexOf(\"javascript\") === -1)\n            ) {\n                // no service worker found. Probably a different app. Reload the page.\n                navigator.serviceWorker.ready.then(registration => {\n                    registration.unregister().then(() => {\n                        window.location.reload();\n                    });\n                });\n            } else {\n                // service worker found. Proceed as normal.\n                registerValidSW(swUrl, config);\n            }\n        })\n        .catch(() => {\n            console.log(\"No internet connection found. App is running in offline mode.\");\n        });\n}\n\nexport function unregister() {\n    if (\"serviceWorker\" in navigator) {\n        navigator.serviceWorker.ready.then(registration => {\n            registration.unregister();\n        });\n    }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n// if you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}