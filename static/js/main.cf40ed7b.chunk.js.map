{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["GAME_INPUT","GAME_IN_PROGRESS","GAME_PAUSE","MINE_HIDDEN","MINE_REVEALED","Timer","props","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","start","Date","now","state","seconds","last","requestAnimationFrame","updateTimer","bind","assertThisInitialized","setState","prevState","running","Math","floor","display","react_default","a","createElement","toLocaleString","undefined","minimumIntegerDigits","Component","Mine","mine","className","concat","minesNear","isMine","customClasses","onClick","handleClick","onContextMenu","handleRightClick","Board","_this2","mines","timer","React","createRef","markedNum","i","height","push","j","width","firstClick","x","y","boundRevealNear","revealNear","minesToTest","getMinesToTest","numMarkedNear","reduce","numMines","coords","mineRevealed","toContinue","forEach","temp","mineRow","rowTotal","_this3","possibilities","length","index","random","coord","splice","playing","updateState","map","objectSpread","validSquaresLeft","_this4","_this5","_this$props","progress","App_Timer","ref","resume","style","marginLeft","window","innerWidth","rowIndex","key","mineIndex","event","preventDefault","max","round","Input","_ref2","handleInputChange","handleSubmit","onSubmit","type","min","value","onChange","App","_this6","app","addEventListener","updates","inputType","defineProperty","target","App_Board","Boolean","location","hostname","match","ReactDOM","render","src_App_0","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.cf40ed7b.chunk.js","sourcesContent":["import React, {Component} from \"react\";\nimport \"./App.css\";\n\n// various states of the game\nconst GAME_INPUT = -1;\nconst GAME_IN_PROGRESS = 0;\nconst GAME_LOSS = 1;\nconst GAME_WIN = 2;\nconst GAME_PAUSE = 3;\n\n// possible states of mines\nconst MINE_HIDDEN = 0;\nconst MINE_REVEALED = 1;\nconst MINE_MARKED = 2;\n\n// timer to tell the player how long their game has been in progress\nclass Timer extends Component {\n    constructor(props) {\n        super(props);\n        // time to indicate when the timer was started\n        this.start = Date.now();\n        this.state = {\n            // amound of seconds that have passed since starting\n            \"seconds\": 0,\n            \"last\": Date.now(),\n        };\n        // ask to update the timer (will occur every rendering until stopped)\n        requestAnimationFrame(this.updateTimer.bind(this));\n    }\n\n    /**\n     * Update the number of seconds for the timer\n     */\n    updateTimer() {\n        this.setState((prevState) => {\n            // update the number of seconds taht have passed since start\n            return {\n                \"seconds\": prevState.seconds + (Date.now() - prevState.last),\n                \"last\": Date.now(),\n            };\n        }, function() {\n            // if we are still running\n            if (this.props.running === true) {\n                // update the timer again\n                requestAnimationFrame(this.updateTimer.bind(this));\n            }\n        });\n    }\n\n    /**\n     * Continue the timer after it was stopped\n     */\n    resume() {\n        this.setState({\n            // update the last tick timing to prevent a large spike in time\n            \"last\": Date.now(),\n        }, function() {\n            // begin the updating loop for the timer\n            requestAnimationFrame(this.updateTimer.bind(this));\n        });\n    }\n\n    render() {\n        // number of seconds to display on timer\n        const seconds = Math.floor(this.state.seconds / 1000);\n        return this.props.display ?\n            // only show timer if that is wanted\n            (<div>\n                {/* Format of timer => `Time: minutes:seconds` */}\n                Time: {Math.floor(seconds / 60)}:\n                {(seconds % 60).toLocaleString(undefined, {\"minimumIntegerDigits\": 2})}\n                {/* if we want to not show timer, just return null */}\n            </div>) : null;\n    }\n}\n\n/**\n * Renders a mine based on its current status\n * @param {Object} props Contains a mine with its state (hidden, revealed, or marked), number of mines near it, a click handler + right click handler, and any potential custom classes\n * @returns {JSX} The rendered mine\n */\nfunction Mine(props) {\n    // get the mine from props\n    const {mine} = props;\n    return (\n        <div\n            // style it as a square on the board\n            // non-revealed mines have no background\n            // if a mine is revealed it should flash red and balck\n            // otherwise just color it based on the number of mines near it (green for none, red for many)\n            className={`mine mineNum${mine.minesNear} ${mine.state !== MINE_REVEALED ? \"hidden\" : mine.isMine ? \"mineLoss\" : \"\"} ${mine.customClasses}`}\n            // set up the click handler\n            onClick={props.handleClick}\n            // set up the right click handler\n            onContextMenu={props.handleRightClick}>\n            {/* don't show any text on hidden mines or revealed non-mines with no mines near them */}\n            {mine.state !== MINE_HIDDEN &&\n                !(mine.state === MINE_REVEALED && mine.isMine === false && mine.minesNear === 0) &&\n                // give the text proper styling\n                <div className=\"label\">\n                    {/* depending on whether or not the mine is revealed */}\n                    {mine.state === MINE_REVEALED ?\n                        // revealed mines show an X, otherwise show how many mines near this non-mine\n                        mine.isMine ? \"X\" : mine.minesNear :\n                        // hidden mines show nothing, marked mines show a !\n                        mine.state === MINE_HIDDEN ? \"\" : \"!\"}\n                </div>}\n        </div>\n    );\n}\n\nclass Board extends Component {\n    constructor(props) {\n        super(props);\n        // array to store the generated mines\n        let mines = [];\n        // ref for the timer so that we can resume it after pause\n        this.timer = React.createRef();\n        // number of marked squares\n        this.markedNum = 0;\n        // create HEIGHT inner arrays (rows)\n        for (let i = 0; i < props.height; ++i) {\n            mines.push([]);\n            // create WIDTH mine states per row (columns)\n            for (let j = 0; j < props.width; ++j) {\n                mines[i].push({\n                    // should start out hidden\n                    \"state\": MINE_HIDDEN,\n                    // will be set later\n                    \"isMine\": false,\n                    // will be set later\n                    \"minesNear\": 0,\n                    // no custom CSS for mines currently\n                    \"customClasses\": \"\",\n                });\n            }\n        }\n        // a click has not yet happened\n        this.firstClick = true;\n        this.state = {\n            // set mines to our (empty) 2-D array\n            \"mines\": mines,\n        };\n    }\n\n    /**\n     * Get all the adjacent coordinates of a specified mine\n     * @param {Number} x X-coordinate of the mine\n     * @param {Number} y Y-coordinate of the mine\n     * @returns {Array} A 2-D array containing adjcanet coordinate pairs\n     */\n    getMinesToTest(x, y) {\n        // block comments refer to the position of the mine to add\n        // where the x indicates the location of the specified\n        // and the * indicates the adjacent mine\n\n        // array to store nearby mines\n        let mines = [];\n        // if we aren't on the left edge\n        if (x > 0) {\n            // if we aren't at the top edge\n            if (y > 0) {\n                /*\n                * - -\n                - x -\n                - - -\n                */\n                mines.push([x - 1, y - 1]);\n            }\n            /*\n            - - -\n            * x -\n            - - -\n            */\n            mines.push([x - 1, y]);\n            // if we aren't on the bottom edge\n            if (y < this.props.height - 1) {\n                /*\n                - - -\n                - x -\n                * - -\n                */\n                mines.push([x - 1, y + 1]);\n            }\n        }\n        // if we aren't at the top edge\n        if (y > 0) {\n            /*\n            - * -\n            - x -\n            - - -\n            */\n            mines.push([x, y - 1]);\n        }\n        // if we aren't on the bottom edge\n        if (y < this.props.height - 1) {\n            /*\n            - - -\n            - x -\n            - * -\n            */\n            mines.push([x, y + 1]);\n        }\n        // if we aren't on the right edge\n        if (x < this.props.width - 1) {\n            // if we aren't at the top edge\n            if (y > 0) {\n                /*\n                - - *\n                - x -\n                - - -\n                */\n                mines.push([x + 1, y - 1]);\n            }\n            /*\n            - - -\n            - x *\n            - - -\n            */\n            mines.push([x + 1, y]);\n            // if we aren't on the bottom edge\n            if (y < this.props.height - 1) {\n                /*\n                - - -\n                - x -\n                - - *\n                */\n                mines.push([x + 1, y + 1]);\n            }\n        }\n        // return our 2-D array of coordinates\n        return mines;\n    }\n\n    /**\n     * Reveal all mines near a target mine recursively\n     * @param {Array} mines 2-D array containing the status of all mines\n     * @param {Number} x X-coordiante of the initially revealed mine\n     * @param {Number} y Y-coordiante of the initially revealed mine\n     * @returns {Object} Contains mines, the updated 2-D mines array, and a mine indicating any if tripped, or null if not\n     */\n    revealNear(mines, x, y) {\n        const boundRevealNear = this.revealNear.bind(this);\n        // get the mines that should be checked\n        const minesToTest = this.getMinesToTest(x, y);\n        // count up all the number of nearby marked squares\n        const numMarkedNear = minesToTest.reduce((numMines, coords) => (\n            numMines + (mines[coords[1]][coords[0]].state === MINE_MARKED ? 1 : 0)\n        ), 0);\n        // variable to store the triggered mine, if any\n        let mineRevealed = null;\n        // if there are exactly as many marked nearby squares as there are mines (user is ready to reveal nearby)\n        if (mines[y][x].minesNear === numMarkedNear) {\n            // for each mine to test\n            let toContinue = true;\n            minesToTest.forEach(function(coords) {\n                if (toContinue) {\n                    // get the mine associated with that coordiante\n                    let mine = mines[coords[1]][coords[0]];\n                    // if the mine is still hidden\n                    if (mine.state === MINE_HIDDEN) {\n                        // reveal it\n                        mine.state = MINE_REVEALED;\n                        // if we tripped a mine\n                        if (mine.isMine) {\n                            mineRevealed = coords;\n                            // indicate that the mine was autotripped\n                            mine.customClasses = \"mineLossAutoClick\";\n                        } else {\n                            // recursively call the reveal function, using the coordinates of the newly revealed mine\n                            const temp = boundRevealNear(mines, coords[0], coords[1]);\n                            // if we didn't trip any mines\n                            if (temp.mineRevealed === null) {\n                                // update the state of the board\n                                mines = temp.mines;\n                            } else {\n                                toContinue = false;\n                                mineRevealed = temp.mineRevealed;\n                            }\n                        }\n                    }\n                }\n            });\n        }\n        // return the mines and any tripped mine, if applicable\n        return {mines, mineRevealed};\n    }\n\n    /**\n     * Calculate how many non-mine squares are unrevealed\n     * @param {Array} mines 2-D array of mines to search through\n     * @returns {Number} The number of unrevealed non-mine squares\n     */\n    validSquaresLeft(mines) {\n        // for each row of mines\n        return mines.reduce((numMines, mineRow) =>\n            // add in a calculated number of mines per row\n            numMines + mineRow.reduce((rowTotal, mine) =>\n                // only add mines that are hidden but not mines\n                rowTotal + (mine.state === MINE_HIDDEN && mine.isMine === false ? 1 : 0\n                ), 0\n            ), 0);\n    }\n\n    // handler for when a mine is clicked\n    handleClick(x, y) {\n        // if this is the first click\n        if (this.firstClick === true) {\n            // generate the mines to ensure a protected first click\n            this.setState(function(prevState) {\n                // get all the coordinates\n                let possibilities = [];\n                for (let i = 0; i < prevState.mines.length; ++i) {\n                    for (let j = 0; j < prevState.mines[i].length; ++j) {\n                        // but don't add the clicked coordinate as a possible mien\n                        if (!(j === x && i === y)) {\n                            possibilities.push([j, i]);\n                        }\n                    }\n                }\n                // generate the desired number of mines\n                for (let i = 0; i < this.props.numMines; ++i) {\n                    // get a random index that isn't the clicked coordinate or already a mine\n                    const index = Math.floor(Math.random() * possibilities.length);\n                    // get the coordinates of that index\n                    const coord = possibilities[index];\n                    // make sure we don't re-pick that for the next mine\n                    possibilities.splice(index, 1);\n                    // set that square to be a mine\n                    prevState.mines[coord[1]][coord[0]].isMine = true;\n                    // for each adjacent square\n                    this.getMinesToTest(coord[0], coord[1]).forEach(function(coords) {\n                        // increment the amount of nearby mines that it has\n                        ++prevState.mines[coords[1]][coords[0]].minesNear;\n                    });\n                }\n                // set our mines\n                return {\n                    \"mines\": prevState.mines,\n                };\n            }, function() {\n                // click has already happened, don't repeat this\n                this.firstClick = false;\n                // do the revealing for that square\n                this.handleClick(x, y);\n            });\n        } else if (this.props.playing === GAME_IN_PROGRESS && this.state.mines[y][x].state !== MINE_MARKED) {\n            // if the game is going on and the mine isn't marked, we can perform a click\n            // if a mine was clicked\n            if (this.state.mines[y][x].isMine) {\n                this.props.updateState({\n                    \"playing\": GAME_LOSS,\n                });\n                this.setState((prevState) => {\n                    // single out the clicked mine\n                    prevState.mines[y][x].customClasses = \"mineLossClick\";\n                    return {\n                        // for each of the rows of mines\n                        \"mines\": prevState.mines.map((mineRow) => (\n                            // for each square in each row\n                            mineRow.map((mine) => {\n                                // set the square to be revealed, unless it was properly marked (show the user their correct markings)\n                                return {\n                                    ...mine,\n                                    \"state\": !(mine.isMine === true && mine.state === MINE_MARKED) ? MINE_REVEALED : MINE_MARKED,\n                                    \"customClasses\": `${mine.customClasses} ${mine.state === MINE_HIDDEN && mine.customClasses !== \"mineLossClick\" ? \"after\" : \"\"}`,\n                                };\n                            })\n                        )),\n                    };\n                });\n            } else {\n                // wasn't a mine\n                this.setState((prevState) => {\n                    // get the current board state\n                    let {mines} = prevState;\n                    // reveal the clicked square\n                    mines[y][x].state = MINE_REVEALED;\n                    // reveal all nearby squares based on marked square\n                    let temp = this.revealNear(mines, x, y);\n                    // if a mine got tripped\n                    if (temp.mineRevealed !== null) {\n                        this.props.updateState({\n                            \"playing\": GAME_LOSS,\n                        });\n                        return {\n                            // for each of the rows of mines\n                            \"mines\": prevState.mines.map((mineRow) => (\n                                // for each square in each row\n                                mineRow.map((mine) => {\n                                    return {\n                                        ...mine,\n                                        // set the square to be revealed, unless it was properly marked (show the user their correct markings)\n                                        // and make any squares revealed after the loss be greyed out\n                                        \"customClasses\": mine.isMine === false && mine.state === MINE_MARKED ? \"falseMark\" : mine.state === MINE_HIDDEN && mine.customClasses !== \"mineLossAutoClick\" ? \"after\" : mine.customClasses,\n                                        \"state\": !(mine.isMine === true && mine.state === MINE_MARKED) ? MINE_REVEALED : MINE_MARKED,\n                                    };\n                                })\n                            )),\n                        };\n                    } else if (this.validSquaresLeft(temp.mines) === 0) {\n                        // if nothing is left, victory!\n                        this.props.updateState({\n                            \"playing\": GAME_WIN,\n                        });\n                        return {\n                            \"mines\": prevState.mines.map((mineRow) => (\n                                // for each square in each row\n                                mineRow.map((mine) => {\n                                    // if it was a mine, mark it (but don't actually make it an X)\n                                    return {\n                                        ...mine,\n                                        \"state\": mine.isMine === true ? MINE_MARKED : MINE_REVEALED,\n                                    };\n                                })\n                            )),\n                        };\n                    } else {\n                        // nothing got tripped, continue\n                        // continue play with the revealed mine\n                        return {\n                            // update the mines\n                            \"mines\": temp.mines,\n                        };\n                    }\n                });\n            }\n        }\n    }\n\n    // handler for when a mine is right clicked\n    handleRightClick(x, y) {\n        if (this.props.playing === GAME_IN_PROGRESS) {\n            // get the mine that was clicked\n            const mine = this.state.mines[y][x];\n            // if it wasn't already revealed\n            if (mine.state !== MINE_REVEALED) {\n                this.setState((prevState) => {\n                    // if it was marked\n                    if (mine.state === MINE_MARKED) {\n                        // set it to be hidden (unmarked)\n                        prevState.mines[y][x].state = MINE_HIDDEN;\n                        // decrement the number of marked mines\n                        --this.markedNum;\n                    } else {\n                        // otherwise set it to be marked\n                        prevState.mines[y][x].state = MINE_MARKED;\n                        // and increment the number of marked mines\n                        ++this.markedNum;\n                    }\n                    return {\n                        // update the toggled mine\n                        \"mines\": prevState.mines,\n                    };\n                });\n            }\n        }\n    }\n\n    render() {\n        // get relevant info from props\n        const {width, height, numMines, playing} = this.props;\n        // number of squares revealed of total number of non-mines, as a percentage\n        const progress = this.firstClick === true ? 0 : 100 - (100 * this.validSquaresLeft(this.state.mines) / (height * width - numMines));\n        return (\n            <div> {/* timer to show how long the game has been, only runs while the player hasn't won or lost */}\n                <Timer running={playing === GAME_IN_PROGRESS} display={playing !== GAME_PAUSE} ref={ref => this.timer = ref} />\n                {(playing === GAME_PAUSE) ? (\n                    // if the game is paused, show the pause screen\n                    <div>\n                        Paused<br />\n                        {/* button that will resume the game */}\n                        <button onClick={() => {\n                            this.props.updateState({\n                                \"playing\": GAME_IN_PROGRESS,\n                            });\n                            this.timer.resume();\n                        }}>\n                            Resume\n                        </button>\n                    </div>\n                ) : (<div>\n                    {/* otherwise, show the main game screen */}\n                    {/* main board, dynamically adjust it to be in the middle of the screen */}\n                    <div\n                        className=\"board\"\n                        style={{\n                            \"marginLeft\": (window.innerWidth - (this.props.width * 27)) / 2,\n                        }}>\n                        {/* generate the board of mines */}\n                        {this.state.mines.map((mineRow, rowIndex) => (\n                            // create a row for each row of mines\n                            <div className=\"row\" key={rowIndex}>\n                                {/* for each mine in the row */}\n                                {mineRow.map((mine, mineIndex) => (\n                                    // generate a mine\n                                    <Mine\n                                        key={mineIndex}\n                                        // pass it the current data of the mine\n                                        mine={mine}\n                                        // pass it the click handler\n                                        handleClick={this.handleClick.bind(this, mineIndex, rowIndex)}\n                                        // pass it the right click handler\n                                        handleRightClick={(event) => {\n                                            // make sure to prevent the default right click popup\n                                            event.preventDefault();\n                                            this.handleRightClick(mineIndex, rowIndex);\n                                        }} />\n                                ))}\n                            </div>\n                        ))}\n                    </div>\n                    {/* helpful info below the board */}\n                    <div className=\"status\">\n                        <div className={playing === GAME_WIN ? \"win\" : \"\"}>\n                            {/* if playing, show number of mines left, or 0 if the user placed too many markers */}\n                            {playing === GAME_IN_PROGRESS ? `Mines Left: ${Math.max(this.props.numMines - this.markedNum, 0)}` :\n                                // otherwise, good job! if the user won, you lost! if the user lost\n                                playing === GAME_WIN ? \"Good job!\" : \"You lost!\"}\n                        </div>\n                        {playing === GAME_IN_PROGRESS &&\n                            <div>\n                                Progress:\n                                {/* the containing blue progress bar, style it as such */}\n                                <div className=\"bar\">\n                                    {/* the inner progress bar */}\n                                    <div\n                                        // necessary styling for the green inner bar\n                                        className=\"innerBar\"\n                                        // make it as wide as the progress, relative to the containing bar\n                                        style={{\"width\": `${progress}%`}}>\n                                        {/* display percent progress to the nearest tenth */}\n                                        {Math.round(10 * progress) / 10}%\n                                    </div>\n                                </div>\n                            </div>}\n                    </div>\n                    {/* if the game ended, offer up a restart */}\n                    {playing !== GAME_IN_PROGRESS ?\n                        <button onClick={this.props.updateState.bind(this, {\n                            \"playing\": GAME_INPUT,\n                        })}>Restart</button> :\n                        <button onClick={this.props.updateState.bind(this, {\n                            \"playing\": GAME_PAUSE,\n                        })}>Pause</button>}\n                </div>)}\n            </div >\n        );\n    }\n}\n\n/**\n * Input form to get game settings\n * @param {Object} props Provides a handler for input change and submit, as well as the current width, height, and number of mines\n * @returns {Component} The rendered input form\n */\nfunction Input({handleInputChange, handleSubmit, height, numMines, width}) {\n    // const {handleInputChange, handleSubmit, height, numMines, width} = this.props;\n    return (\n        <form onSubmit={handleSubmit.bind(this)}>\n            {/* input for width of board */}\n            <label>Board width <input\n                // make it a numeric input\n                type=\"number\"\n                // need at least 1 wide board\n                min={1}\n                // don't make it too wide or weird wrapping happens\n                max={window.innerWidth / 25 - 6}\n                // initially set to whatever the width was\n                value={width}\n                onChange={handleInputChange.bind(this, \"width\")} />\n            </label>\n            {/* input for height of board */}\n            <label>Board height <input\n                // make it a numeric input\n                type=\"number\"\n                // need at least 1 tall board\n                min={1}\n                // initially set to whatever the height was\n                value={height}\n                onChange={handleInputChange.bind(this, \"height\")}\n            />\n            </label>\n            {/* input for number of mines */}\n            <label>Number of mines <input\n                // make it a numeric input\n                type=\"number\"\n                // need at least 1 mine\n                min={1}\n                // must have at least 1 non-mine\n                max={width * height - 1}\n                // initially set to whatever the number of mines was\n                value={numMines}\n                onChange={handleInputChange.bind(this, \"numMines\")} />\n            </label>\n            {/* button to start playing */}\n            <input type=\"submit\" value=\"Play!\" />\n        </form>\n    );\n}\n\nclass App extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            // start out in the input phase\n            \"playing\": GAME_INPUT,\n            \"width\": 30,\n            \"height\": 15,\n            \"numMines\": 75,\n        };\n        // variable so that the callback can set the app's state\n        const app = this;\n        // when the window loses focus\n        window.addEventListener(\"blur\", function() {\n            // update the state of the app\n            app.setState((prevState) => {\n                return {\n                    // if we were in a game, pause it, otherwise nothing to do\n                    \"playing\": prevState.playing === GAME_IN_PROGRESS ? GAME_PAUSE : prevState.playing,\n                };\n            });\n        }, false);\n    }\n\n    updateState(updates) {\n        this.setState(updates);\n    }\n\n    handleSubmit(event) {\n        event.preventDefault();\n        this.setState({\n            \"playing\": GAME_IN_PROGRESS,\n        });\n    }\n\n    handleInputChange(inputType, event) {\n        this.setState({\n            [inputType]: event.target.value,\n        });\n    }\n\n    render() {\n        return (\n            <div>\n                {/* are we playing the game? */}\n                {this.state.playing !== GAME_INPUT ?\n                    // if so, show the game!\n                    <Board\n                        width={this.state.width}\n                        height={this.state.height}\n                        numMines={this.state.numMines}\n                        playing={this.state.playing}\n                        updateState={this.updateState.bind(this)} /> :\n                    // otherwise, waiting on user input, show the form\n                    <Input\n                        width={this.state.width}\n                        height={this.state.height}\n                        numMines={this.state.numMines}\n                        handleSubmit={this.handleSubmit.bind(this)}\n                        handleInputChange={this.handleInputChange.bind(this)} />}\n            </div>\n        );\n    }\n}\n\nexport default App;\n","// this optional code is used to register a service worker.\n// register() is not called by default.\n\n// this lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// to learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n    window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n        /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n    if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n        // the URL constructor is available in all browsers that support SW.\n        const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n        if (publicUrl.origin !== window.location.origin) {\n            // our service worker won't work if PUBLIC_URL is on a different origin\n            // from what our page is served on. This might happen if a CDN is used to\n            // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n            return;\n        }\n\n        window.addEventListener(\"load\", () => {\n            const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n            if (isLocalhost) {\n                // this is running on localhost. Let's check if a service worker still exists or not.\n                checkValidServiceWorker(swUrl, config);\n\n                // add some additional logging to localhost, pointing developers to the\n                // service worker/PWA documentation.\n                navigator.serviceWorker.ready.then(() => {\n                    console.log(\n                        \"This web app is being served cache-first by a service \" +\n                        \"worker. To learn more, visit http://bit.ly/CRA-PWA\"\n                    );\n                });\n            } else {\n                // is not localhost. Just register service worker\n                registerValidSW(swUrl, config);\n            }\n        });\n    }\n}\n\nfunction registerValidSW(swUrl, config) {\n    navigator.serviceWorker\n        .register(swUrl)\n        .then(registration => {\n            registration.onupdatefound = () => {\n                const installingWorker = registration.installing;\n                if (installingWorker == null) {\n                    return;\n                }\n                installingWorker.onstatechange = () => {\n                    if (installingWorker.state === \"installed\") {\n                        if (navigator.serviceWorker.controller) {\n                            // at this point, the updated precached content has been fetched,\n                            // but the previous service worker will still serve the older\n                            // content until all client tabs are closed.\n                            console.log(\n                                \"New content is available and will be used when all \" +\n                                \"tabs for this page are closed. See http://bit.ly/CRA-PWA.\"\n                            );\n\n                            // execute callback\n                            if (config && config.onUpdate) {\n                                config.onUpdate(registration);\n                            }\n                        } else {\n                            // at this point, everything has been precached.\n                            // it's the perfect time to display a\n                            // \"Content is cached for offline use.\" message.\n                            console.log(\"Content is cached for offline use.\");\n\n                            // execute callback\n                            if (config && config.onSuccess) {\n                                config.onSuccess(registration);\n                            }\n                        }\n                    }\n                };\n            };\n        })\n        .catch(error => {\n            console.error(\"Error during service worker registration:\", error);\n        });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n    // check if the service worker can be found. If it can't reload the page.\n    fetch(swUrl)\n        .then(response => {\n            // ensure service worker exists, and that we really are getting a JS file.\n            const contentType = response.headers.get(\"content-type\");\n            if (\n                response.status === 404 ||\n                (contentType != null && contentType.indexOf(\"javascript\") === -1)\n            ) {\n                // no service worker found. Probably a different app. Reload the page.\n                navigator.serviceWorker.ready.then(registration => {\n                    registration.unregister().then(() => {\n                        window.location.reload();\n                    });\n                });\n            } else {\n                // service worker found. Proceed as normal.\n                registerValidSW(swUrl, config);\n            }\n        })\n        .catch(() => {\n            console.log(\"No internet connection found. App is running in offline mode.\");\n        });\n}\n\nexport function unregister() {\n    if (\"serviceWorker\" in navigator) {\n        navigator.serviceWorker.ready.then(registration => {\n            registration.unregister();\n        });\n    }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n// if you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}