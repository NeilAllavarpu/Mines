{"version":3,"sources":["Mine.js","Timer.js","ScoreBoard.js","Board.js","Input.js","App.js","serviceWorker.js","index.js"],"names":["Mine","_ref","mine","mineSize","handleClick","handleRightClick","classes","concat","customClasses","labelText","state","MINE","REVEALED","isMine","minesNear","MARKED","react_default","a","createElement","className","onClick","onContextMenu","style","fontSize","height","lineHeight","width","Timer","_React$Component","props","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","start","Date","now","last","timePassed","requestID","inherits","createClass","key","value","_this2","window","requestAnimationFrame","updateTimer","_this3","setState","prevState","running","bind","cancelAnimationFrame","_this4","display","Math","floor","minutes","seconds","toLocaleString","minimumIntegerDigits","React","Component","ScoreBoard","apply","arguments","scores","localStorage","getItem","split","map","score","updateState","playing","GAME","INPUT","Board","mines","timer","createRef","markedNum","i","push","j","HIDDEN","firstClick","hasFinished","mineX","mineY","minesToTest","getMinesToTest","numMarkedNear","reduce","numMines","coords","index","length","triggerLoss","mineRevealed","temp","revealNear","row","element","square","objectSpread","clickX","clickY","possibilities","random","coord","splice","forEach","IN_PROGRESS","LOSS","validSquaresLeft","WIN","parseFloat","console","log","getTime","sort","setItem","mineRow","mainContent","progress","button","status","message","_this$props","PAUSE","resume","max","round","rowIndex","mineIndex","event","preventDefault","ScoreBoard_ScoreBoard","Timer_Timer","ref","rowTotal","Input","handleInputChange","handleSubmit","onSubmit","type","min","innerWidth","name","onChange","App","addEventListener","updates","defineProperty","target","Board_Board","Boolean","location","hostname","match","ReactDOM","render","src_App_0","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.8e93252c.chunk.js","sourcesContent":["import {MINE} from \"./constants.json\";\nimport PropTypes from \"prop-types\";\nimport React from \"react\";\n\n/**\n * Renders a mine based on its current status\n * @param {Object} props Contains a mine with its state (hidden, revealed, or marked), number of mines near it, a click handler + right click handler, and any potential custom classes\n * @returns {JSX} The rendered mine\n */\nexport function Mine({mine, mineSize, handleClick, handleRightClick}) {\n    // CSS classes of the mine\n    let classes = `mine ${mine.customClasses}`,\n        // text to show on the mine\n        labelText = null;\n    // if the mine is revealed\n    if (mine.state === MINE.REVEALED) {\n        // if it is a mine\n        if (mine.isMine === true) {\n            // style it as a mine\n            classes += \" mineLoss\";\n            // revealed mines show a X\n            labelText = \"X\";\n        } else {\n            // not a mine, style it based on number of nearby mines\n            classes += ` mineNum${mine.minesNear}`;\n            // don't show 0 on squares\n            if (mine.minesNear !== 0) {\n                // any other number of nearby mines should be displayed\n                labelText = mine.minesNear;\n            }\n        }\n    } else if (mine.state === MINE.MARKED) {\n        // marked squares show a !\n        labelText = \"!\";\n    }\n    return (\n        <div\n            // set the computed classes\n            className={classes}\n            // set up the click handler\n            onClick={handleClick}\n            // set up the right click handler\n            onContextMenu={handleRightClick}\n            style={{\n                \"fontSize\": mineSize,\n                \"height\": mineSize,\n                \"lineHeight\": mineSize,\n                \"width\": mineSize,\n            }}>\n            {/* show the computed text */}\n            <div className=\"label\">{labelText}</div>\n        </div>\n    );\n}\n\nMine.propTypes = {\n    \"handleClick\": PropTypes.func.isRequired,\n    \"handleRightClick\": PropTypes.func.isRequired,\n    \"mine\": PropTypes.object.isRequired,\n    \"mineSize\": PropTypes.number.isRequired,\n};\n","import PropTypes from \"prop-types\";\nimport React from \"react\";\n\nconst msPerSecond = 1000,\n    secondsPerMinute = 60;\n\nexport class Timer extends React.Component {\n    constructor(props) {\n        super(props);\n        // time to indicate when the timer was started\n        this.start = Date.now();\n        this.state = {\n            \"last\": Date.now(),\n            // amound of seconds that have passed since starting\n            \"timePassed\": 0,\n        };\n        // ask to update the timer (will occur every rendering until stopped)\n        this.requestID = null;\n    }\n\n    componentDidMount() {\n        this.requestID = window.requestAnimationFrame(() => {\n            this.updateTimer();\n        });\n    }\n\n    /**\n     * Update the number of seconds for the timer\n     */\n    updateTimer() {\n        this.setState((prevState) => ({\n            \"last\": Date.now(),\n            // update the number of seconds taht have passed since start\n            \"timePassed\": prevState.timePassed + (Date.now() - prevState.last),\n        }), () => {\n            // if we are still running\n            if (this.props.running === true) {\n                // update the timer again\n                window.requestAnimationFrame(this.updateTimer.bind(this));\n            }\n        });\n    }\n\n    componentWillUnmount() {\n        window.cancelAnimationFrame(this.requestID);\n    }\n\n    /**\n     * Continues the timer after it was stopped\n     */\n    resume() {\n        this.setState({\n            // update the last tick timing to prevent a large spike in time\n            \"last\": Date.now(),\n        }, () => {\n            // begin the updating loop for the timer\n            window.requestAnimationFrame(this.updateTimer.bind(this));\n        });\n    }\n\n    getTime() {\n        return this.state.timePassed / 1000;\n    }\n\n    render() {\n        // only show timer if that is wanted\n        if (this.props.display === true) {\n            // number of seconds to display on timer\n            const timePassed = Math.floor(this.state.timePassed / msPerSecond),\n                // minutes part of the time\n                minutes = Math.floor(timePassed / secondsPerMinute),\n                // seconds part of the time\n                seconds = (timePassed % secondsPerMinute).toLocaleString([], {\n                    \"minimumIntegerDigits\": 2,\n                });\n            return (\n                <div>Time: {minutes}:{seconds}</div>\n            );\n        } else {\n            return null;\n        }\n    }\n}\n\nTimer.propTypes = {\n    \"display\": PropTypes.bool.isRequired,\n    \"running\": PropTypes.bool.isRequired,\n};\n","import React from \"react\";\nimport {GAME} from \"./constants.json\";\n\nexport class ScoreBoard extends React.Component {\n    render() {\n        let scores = localStorage.getItem(\"scores\");\n        if (scores) {\n            scores = scores.split(\",\")\n            return (\n                <div>\n                    <h2>Fastest Times</h2>\n                    <ol>\n                        {scores.map((score) => (\n                            <li>\n                                {Math.floor(score / 60)}:{(score % 60).toLocaleString([], {\n                                    \"minimumIntegerDigits\": 2,\n                                })}\n                            </li>\n                        ))}\n                    </ol>\n                    <button onClick={this.props.updateState.bind(this, {\n                        \"playing\": GAME.INPUT,\n                    })}>Restart</button>\n                </div>\n            );\n        } else {\n            return (\n                <div>\n                    Play to get some times here!\n                </div>\n            );\n        }\n    }\n}\n","import {GAME, MINE} from \"./constants.json\";\nimport {Mine} from \"./Mine.js\";\nimport PropTypes from \"prop-types\";\nimport React from \"react\";\nimport {Timer} from \"./Timer.js\";\nimport {ScoreBoard} from \"./ScoreBoard.js\";\n\nconst pct = 100;\n\nexport class Board extends React.Component {\n    constructor(props) {\n        super(props);\n        // array to store the generated mines\n        let mines = [];\n        // ref for the timer so that we can resume it after pause\n        this.timer = React.createRef();\n        // number of marked squares\n        this.markedNum = 0;\n        // create HEIGHT inner arrays (rows)\n        for (let i = 0; i < props.height; ++i) {\n            mines.push([]);\n            // create WIDTH mine states per row (columns)\n            for (let j = 0; j < props.width; ++j) {\n                mines[i].push({\n                    // no custom CSS for mines currently\n                    \"customClasses\": \"\",\n                    // will be set later\n                    \"isMine\": false,\n                    // will be set later\n                    \"minesNear\": 0,\n                    // should start out hidden\n                    \"state\": MINE.HIDDEN,\n                });\n            }\n        }\n        // a click has not yet happened\n        this.firstClick = true;\n        this.state = {\n            // set mines to our (empty) 2-D array\n            mines,\n            \"hasFinished\": false,\n        };\n    }\n\n    /**\n     * Get all the adjacent coordinates of a specified mine\n     * @param {Number} mineX X-coordinate of the mine\n     * @param {Number} mineY Y-coordinate of the mine\n     * @returns {Array} A 2-D array containing adjacent coordinate pairs\n     */\n    getMinesToTest(mineX, mineY) {\n        // 3-line comments refer to the position of the mine to add\n        // where the x indicates the location of the specified\n        // and the * indicates the adjacent mine\n\n        // array to store nearby mines\n        let mines = [];\n        // if we aren't on the left edge\n        if (mineX > 0) {\n            // if we aren't at the top edge\n            if (mineY > 0) {\n                // - -\n                // - x -\n                // - - -\n                mines.push([mineX - 1, mineY - 1]);\n            }\n            // - - -\n            // x -\n            // - - -\n            mines.push([mineX - 1, mineY]);\n            // if we aren't on the bottom edge\n            if (mineY < this.props.height - 1) {\n                // - - -\n                // - x -\n                // - -\n                mines.push([mineX - 1, mineY + 1]);\n            }\n        }\n        // if we aren't at the top edge\n        if (mineY > 0) {\n            // - * -\n            // - x -\n            // - - -\n            mines.push([mineX, mineY - 1]);\n        }\n        // if we aren't on the bottom edge\n        if (mineY < this.props.height - 1) {\n            // - - -\n            // - x -\n            // - * -\n            mines.push([mineX, mineY + 1]);\n        }\n        // if we aren't on the right edge\n        if (mineX < this.props.width - 1) {\n            // if we aren't at the top edge\n            if (mineY > 0) {\n                // - - *\n                // - x -\n                // - - -\n                mines.push([mineX + 1, mineY - 1]);\n            }\n            // - - -\n            // - x *\n            // - - -\n            mines.push([mineX + 1, mineY]);\n            // if we aren't on the bottom edge\n            if (mineY < this.props.height - 1) {\n                // - - -\n                // - x -\n                // - - *\n                mines.push([mineX + 1, mineY + 1]);\n            }\n        }\n        // return our 2-D array of coordinates\n        return mines;\n    }\n\n    /**\n     * Reveal all mines near a target mine recursively\n     * @param {Array} mines 2-D array containing the status of all mines\n     * @param {Number} mineX X-coordiante of the initially revealed mine\n     * @param {Number} mineY Y-coordiante of the initially revealed mine\n     * @returns {Object} Contains mines, the updated 2-D mines array, and a mine indicating any if tripped, or null if not\n     */\n    revealNear(mines, mineX, mineY) {\n        // get the mines that should be checked\n        const minesToTest = this.getMinesToTest(mineX, mineY),\n            // count up all the number of nearby marked squares\n            numMarkedNear = minesToTest.reduce((numMines, coords) => {\n                if (mines[coords[1]][coords[0]].state === MINE.MARKED) {\n                    return numMines + 1;\n                } else {\n                    return numMines;\n                }\n            }, 0);\n        // if there are as many marked nearby squares as there are nearby mines, begin the reveal\n        if (mines[mineY][mineX].minesNear === numMarkedNear) {\n            for (let index = 0; index < minesToTest.length; index++) {\n                const coords = minesToTest[index];\n                let mine = mines[coords[1]][coords[0]];\n                if (mine.state === MINE.MARKED && mine.isMine === false) {\n                    this.triggerLoss();\n                    return {\n                        \"mineRevealed\": true,\n                        mines,\n                    };\n                } else {\n                    // get the mine associated with that coordiante\n                    let mine = mines[coords[1]][coords[0]];\n                    // if the mine is still hidden\n                    if (mine.state === MINE.HIDDEN) {\n                        // if we tripped a mine\n                        if (mine.isMine) {\n                            // end it all\n                            this.triggerLoss();\n                            return {\n                                \"mineRevealed\": true,\n                                mines,\n                            };\n                        } else {\n                            // reveal it\n                            mine.state = MINE.REVEALED;\n                            // recursively call the reveal function, using the coordinates of the newly revealed mine\n                            const temp = this.revealNear(mines, coords[0], coords[1]);\n                            // if we didn't trip any mines\n                            if (temp.mineRevealed === false) {\n                                // update the state of the board\n                                mines = temp.mines;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        // return the mines and any tripped mine, if applicable\n        return {\n            \"mineRevealed\": false,\n            mines,\n        };\n    }\n\n    /**\n     * Calculate how many non-mine squares are unrevealed\n     * @param {Array} mines 2-D array of mines to search through\n     * @returns {Number} The number of unrevealed non-mine squares\n     */\n    static validSquaresLeft(mines) {\n        // count up all the hidden non-mine squares remaining of all rows\n        return mines.reduce((numMines, mineRow) => numMines + mineRow.reduce((rowTotal, mine) => {\n            if (mine.state === MINE.HIDDEN && mine.isMine === false) {\n                return rowTotal + 1;\n            } else {\n                return rowTotal;\n            }\n        }, 0), 0);\n    }\n\n    triggerLoss() {\n        this.setState((prevState) => ({\n            // for each square on the board\n            \"mines\": prevState.mines.map((row) => row.map((element) => {\n                // shallow copy the square\n                let square = {...element};\n                // notify of any false marks\n                if (square.isMine === false && square.state === MINE.MARKED) {\n                    square.customClasses += \" falseMark\";\n                }\n                // any untouched mines are grayed out\n                if (square.state === MINE.HIDDEN) {\n                    square.customClasses += \" after\";\n                }\n                if (!(square.isMine === true && square.state === MINE.MARKED)) {\n                    square.state = MINE.REVEALED;\n                }\n                return square;\n            })),\n        }));\n    }\n\n    // handler for when a mine is clicked\n    handleClick(clickX, clickY) {\n        let {mines} = this.state;\n        // if this is the first click\n        if (this.firstClick === true) {\n            // generate the mines to ensure a protected first click\n            this.setState((prevState) => {\n                // get all the coordinates\n                let possibilities = [];\n                for (let i = 0; i < prevState.mines.length; ++i) {\n                    for (let j = 0; j < prevState.mines[i].length; ++j) {\n                        // but don't add the clicked coordinate as a possible mine\n                        if (!(j === clickX && i === clickY)) {\n                            possibilities.push([j, i]);\n                        }\n                    }\n                }\n                // generate the desired number of mines\n                for (let i = 0; i < this.props.numMines; ++i) {\n                    // get a random index that isn't the clicked coordinate or already a mine\n                    const index = Math.floor(Math.random() * possibilities.length),\n                        // get the coordinates of that index\n                        coord = possibilities[index];\n                    // make sure we don't re-pick that for the next mine\n                    possibilities.splice(index, 1);\n                    // set that square to be a mine\n                    prevState.mines[coord[1]][coord[0]].isMine = true;\n                    // for each adjacent square\n                    this.getMinesToTest(coord[0], coord[1])\n                        .forEach((coords) => {\n                            // increment the amount of nearby mines that it has\n                            ++prevState.mines[coords[1]][coords[0]].minesNear;\n                        });\n                }\n                // set our mines\n                return {\n                    \"mines\": prevState.mines,\n                };\n            }, () => {\n                // click has already happened, don't repeat this\n                this.firstClick = false;\n                // do the revealing for that square\n                this.handleClick(clickX, clickY);\n            });\n        } else if (this.props.playing === GAME.IN_PROGRESS &&\n            this.state.mines[clickY][clickX].state !== MINE.MARKED) {\n            // if the game is going on and the mine isn't marked, perform a click\n            mines[clickY][clickX].state = MINE.REVEALED;\n            // if a mine was clicked\n            if (mines[clickY][clickX].isMine) {\n                this.props.updateState({\n                    // set the game to a losss\n                    \"playing\": GAME.LOSS,\n                });\n                // specially mark the clicked mine\n                mines[clickY][clickX].customClasses += \" mineLossClick\";\n                this.setState({\n                    // update the mines\n                    mines,\n                    // then trigger a loss\n                }, this.triggerLoss);\n            } else {\n                // wasn't a mine, reveal all nearby squares based on marked squares\n                let temp = this.revealNear(mines, clickX, clickY);\n                // if a mine got tripped\n                if (temp.mineRevealed === true) {\n                    this.props.updateState({\n                        \"playing\": GAME.LOSS,\n                    });\n                    this.triggerLoss();\n                } else if (Board.validSquaresLeft(temp.mines) === 0) {\n                    // if nothing is left, victory!\n                    this.props.updateState({\n                        \"playing\": GAME.WIN,\n                    });\n                    let scores = localStorage.getItem(\"scores\").split(\",\");\n                    scores = scores.map((score) => parseFloat(score));\n                    console.log(scores)\n                    scores.push(this.timer.getTime());\n                    scores.sort();\n                    scores.splice(10);\n                    localStorage.setItem(\"scores\", scores);\n                    console.log(localStorage.getItem(\"scores\").split(\",\"))\n                    this.setState({\n                        // for each of the squares\n                        \"mines\": temp.mines.map((mineRow) => mineRow.map((element) => {\n                            let mine = element;\n                            // if it was a mine, mark it (but don't actually make it an X)\n                            if (mine.isMine === true) {\n                                mine.state = MINE.MARKED;\n                            }\n                            return mine;\n                        })),\n                        \"hasFinished\": true,\n                    });\n                } else {\n                    // nothing got tripped, continue play with the revealed mine(s)\n                    this.setState({\n                        \"mines\": temp.mines,\n                    });\n                }\n            }\n        }\n    }\n\n    // handler for when a mine is right clicked\n    handleRightClick(clickX, clickY) {\n        if (this.props.playing === GAME.IN_PROGRESS) {\n            // get the mine that was clicked\n            const mine = this.state.mines[clickY][clickX];\n            // if it wasn't already revealed\n            if (mine.state !== MINE.REVEALED) {\n                this.setState((prevState) => {\n                    // if it was marked\n                    if (mine.state === MINE.MARKED) {\n                        // set it to be hidden (unmarked)\n                        prevState.mines[clickY][clickX].state = MINE.HIDDEN;\n                        // decrement the number of marked mines\n                        --this.markedNum;\n                    } else {\n                        // otherwise set it to be marked\n                        prevState.mines[clickY][clickX].state = MINE.MARKED;\n                        // and increment the number of marked mines\n                        ++this.markedNum;\n                    }\n                    return {\n                        // update the toggled mine\n                        \"mines\": prevState.mines,\n                    };\n                });\n            }\n        }\n    }\n\n    render() {\n        // get relevant info from props\n        const {width, height, numMines, playing} = this.props;\n        // number of squares revealed of total number of non-mines, as a percentage\n        let mainContent, progress;\n        if (this.firstClick === true) {\n            progress = 0;\n        } else {\n            progress = pct - (pct * Board.validSquaresLeft(this.state.mines) / ((height * width) - numMines));\n        }\n        if (playing === GAME.PAUSE) {\n            mainContent = (\n                // if the game is paused, show the pause screen\n                <div>\n                    Paused<br />\n                    {/* button that will resume the game */}\n                    <button onClick={() => {\n                        this.props.updateState({\n                            \"playing\": GAME.IN_PROGRESS,\n                        });\n                        this.timer.resume();\n                    }}>\n                        Resume\n                    </button>\n                </div>\n            );\n        } else {\n            let button, status, message, mineSize;\n            // while playing, show the blue and green progress bar\n            if (playing === GAME.IN_PROGRESS) {\n                status = (\n                    <div className=\"status\">\n                        {/* show the \"number of mines left\", or 0 if too many are flagged */}\n                        <div>Mines Left: {Math.max(this.props.numMines - this.markedNum, 0)}</div>\n                        <div>\n                            Progress:\n                            <div className=\"bar\">\n                                <div\n                                    // necessary styling for the green inner bar\n                                    className=\"innerBar\"\n                                    // make it be proportionally sized to the progress\n                                    style={{\"width\": `${progress}%`}}>\n                                    {/* display percent progress to the nearest tenth */}\n                                    {Math.round(10 * progress) / 10}%\n                                </div>\n                            </div>\n                        </div>\n                    </div>\n                );\n                button = (\n                    <button onClick={this.props.updateState.bind(this, {\n                        \"playing\": GAME.PAUSE,\n                    })}>Pause</button>\n                );\n            } else {\n                button = (\n                    <button onClick={this.props.updateState.bind(this, {\n                        \"playing\": GAME.INPUT,\n                    })}>Restart</button>\n                );\n            }\n            if (playing === GAME.WIN) {\n                message = <div className=\"status win\">Good job!</div>;\n            } else if (playing === GAME.LOSS) {\n                message = <div className=\"status\">You lost!</div>;\n            }\n            if (80 / this.props.width < 80 / this.props.height) {\n                mineSize = `${80 / this.props.width}vw`;\n            } else {\n                mineSize = `${80 / this.props.height}vh`;\n            }\n            mainContent = (\n                <div>\n                    {/* main board, dynamically adjust it to be in the middle of the screen */}\n                    <div className=\"board\">\n                        {/* generate the board of mines */}\n                        {this.state.mines.map((mineRow, rowIndex) => (\n                            // create a row for each row of mines\n                            <div className=\"row\" key={rowIndex}>\n                                {/* for each mine in the row */}\n                                {mineRow.map((mine, mineIndex) => (\n                                    // generate a mine\n                                    <Mine\n                                        key={mineIndex}\n                                        // pass it the current data of the mine\n                                        mine={mine}\n                                        // pass it the click handler\n                                        handleClick={() => {\n                                            this.handleClick(mineIndex, rowIndex);\n                                        }}\n                                        mineSize={mineSize}\n                                        // pass it the right click handler\n                                        handleRightClick={(event) => {\n                                            // make sure to prevent the default right click popup\n                                            event.preventDefault();\n                                            this.handleRightClick(mineIndex, rowIndex);\n                                        }} />\n                                ))}\n                            </div>\n                        ))}\n                    </div>\n                    {/* helpful info below the board */}\n                    {status}\n                    {message}\n                    {/* if the game ended, offer up a restart */}\n                    {button}\n                </div>\n            );\n        }\n        if (this.state.hasFinished) {\n            mainContent = <ScoreBoard updateState={this.props.updateState.bind(this)} />;\n        }\n        return (\n            <div>\n                {/* timer to show how long the game has been */}\n                {!this.firstClick && <Timer\n                    // only running while game is playing\n                    running={playing === GAME.IN_PROGRESS}\n                    // don't show on pause screen\n                    display={playing !== GAME.PAUSE && playing !== GAME.WIN}\n                    ref={(ref) => {\n                        this.timer = ref;\n                    }} />}\n                {mainContent}\n            </div >\n        );\n    }\n}\n\nBoard.propTypes = {\n    \"height\": PropTypes.number.isRequired,\n    \"numMines\": PropTypes.number.isRequired,\n    \"playing\": PropTypes.number.isRequired,\n    \"updateState\": PropTypes.func.isRequired,\n    \"width\": PropTypes.number.isRequired,\n};\n","import PropTypes from \"prop-types\";\nimport React from \"react\";\n\n/**\n * Input form to get game settings\n * @param {Object} props Provides a handler for input change and submit, as well as the current width, height, and number of mines\n * @returns {Component} The rendered input form\n */\nexport function Input({handleInputChange, handleSubmit, height, numMines, width}) {\n    // const {handleInputChange, handleSubmit, height, numMines, width} = this.props;\n    return (\n        <form onSubmit={handleSubmit.bind(this)}>\n            {/* input for width of board */}\n            <label>Board width <input\n                // make it a numeric input\n                type=\"number\"\n                // need at least 1 wide board\n                min={1}\n                // don't make it too wide or weird wrapping happens\n                max={Math.floor(window.innerWidth / 6)}\n                // initially set to whatever the width was\n                value={width}\n                name=\"width\"\n                onChange={handleInputChange.bind(this)} />\n            </label>\n            {/* input for height of board */}\n            <label>Board height <input\n                // make it a numeric input\n                type=\"number\"\n                // need at least 1 tall board\n                min={1}\n                // initially set to whatever the height was\n                value={height}\n                name=\"height\"\n                onChange={handleInputChange.bind(this)}\n            />\n            </label>\n            {/* input for number of mines */}\n            <label>Number of mines <input\n                // make it a numeric input\n                type=\"number\"\n                // need at least 1 mine\n                min={1}\n                // must have at least 1 non-mine\n                max={(width * height) - 1}\n                // initially set to whatever the number of mines was\n                value={numMines}\n                name=\"numMines\"\n                onChange={handleInputChange.bind(this)} />\n            </label>\n            {/* button to start playing */}\n            <input type=\"submit\" value=\"Play!\" />\n        </form>\n    );\n}\n\nInput.propTypes = {\n    \"handleInputChange\": PropTypes.func.isRequired,\n    \"handleSubmit\": PropTypes.func.isRequired,\n    \"height\": PropTypes.number.isRequired,\n    \"numMines\": PropTypes.number.isRequired,\n    \"width\": PropTypes.number.isRequired,\n};\n","import \"./App.css\";\nimport {Board} from \"./Board.js\";\nimport {GAME} from \"./constants.json\";\nimport {Input} from \"./Input.js\";\nimport React from \"react\";\n\nclass App extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            // start out in the input phase\n            \"height\": 15,\n            \"numMines\": 75,\n            \"playing\": GAME.INPUT,\n            \"width\": 30,\n        };\n    }\n\n    componentDidMount() {\n        // when the window loses focus\n        window.addEventListener(\"blur\", () => {\n            // if we were in a game, pause it\n            if (this.state.playing === GAME.IN_PROGRESS) {\n                this.setState({\n                    \"playing\": GAME.PAUSE,\n                });\n            }\n        });\n    }\n\n    updateState(updates) {\n        this.setState(updates);\n    }\n\n    handleSubmit(event) {\n        event.preventDefault();\n        this.setState({\n            \"playing\": GAME.IN_PROGRESS,\n        });\n    }\n\n    handleInputChange(event) {\n        this.setState({\n            [event.target.name]: event.target.value,\n        });\n    }\n\n    render() {\n        if (this.state.playing === GAME.INPUT) {\n            return (\n                <Input\n                    width={this.state.width}\n                    height={this.state.height}\n                    numMines={this.state.numMines}\n                    handleSubmit={this.handleSubmit.bind(this)}\n                    handleInputChange={this.handleInputChange.bind(this)} />\n            );\n        } else {\n            return (\n                <Board\n                    width={this.state.width}\n                    height={this.state.height}\n                    numMines={this.state.numMines}\n                    playing={this.state.playing}\n                    updateState={this.updateState.bind(this)} />\n            );\n        }\n    }\n}\n\nexport default App;\n","// this optional code is used to register a service worker.\n// register() is not called by default.\n\n// this lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// to learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n    window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n        /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n    if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n        // the URL constructor is available in all browsers that support SW.\n        const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n        if (publicUrl.origin !== window.location.origin) {\n            // our service worker won't work if PUBLIC_URL is on a different origin\n            // from what our page is served on. This might happen if a CDN is used to\n            // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n            return;\n        }\n\n        window.addEventListener(\"load\", () => {\n            const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n            if (isLocalhost) {\n                // this is running on localhost. Let's check if a service worker still exists or not.\n                checkValidServiceWorker(swUrl, config);\n\n                // add some additional logging to localhost, pointing developers to the\n                // service worker/PWA documentation.\n                navigator.serviceWorker.ready.then(() => {\n                    console.log(\n                        \"This web app is being served cache-first by a service \" +\n                        \"worker. To learn more, visit http://bit.ly/CRA-PWA\"\n                    );\n                });\n            } else {\n                // is not localhost. Just register service worker\n                registerValidSW(swUrl, config);\n            }\n        });\n    }\n}\n\nfunction registerValidSW(swUrl, config) {\n    navigator.serviceWorker\n        .register(swUrl)\n        .then(registration => {\n            registration.onupdatefound = () => {\n                const installingWorker = registration.installing;\n                if (installingWorker == null) {\n                    return;\n                }\n                installingWorker.onstatechange = () => {\n                    if (installingWorker.state === \"installed\") {\n                        if (navigator.serviceWorker.controller) {\n                            // at this point, the updated precached content has been fetched,\n                            // but the previous service worker will still serve the older\n                            // content until all client tabs are closed.\n                            console.log(\n                                \"New content is available and will be used when all \" +\n                                \"tabs for this page are closed. See http://bit.ly/CRA-PWA.\"\n                            );\n\n                            // execute callback\n                            if (config && config.onUpdate) {\n                                config.onUpdate(registration);\n                            }\n                        } else {\n                            // at this point, everything has been precached.\n                            // it's the perfect time to display a\n                            // \"Content is cached for offline use.\" message.\n                            console.log(\"Content is cached for offline use.\");\n\n                            // execute callback\n                            if (config && config.onSuccess) {\n                                config.onSuccess(registration);\n                            }\n                        }\n                    }\n                };\n            };\n        })\n        .catch(error => {\n            console.error(\"Error during service worker registration:\", error);\n        });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n    // check if the service worker can be found. If it can't reload the page.\n    fetch(swUrl)\n        .then(response => {\n            // ensure service worker exists, and that we really are getting a JS file.\n            const contentType = response.headers.get(\"content-type\");\n            if (\n                response.status === 404 ||\n                (contentType != null && contentType.indexOf(\"javascript\") === -1)\n            ) {\n                // no service worker found. Probably a different app. Reload the page.\n                navigator.serviceWorker.ready.then(registration => {\n                    registration.unregister().then(() => {\n                        window.location.reload();\n                    });\n                });\n            } else {\n                // service worker found. Proceed as normal.\n                registerValidSW(swUrl, config);\n            }\n        })\n        .catch(() => {\n            console.log(\"No internet connection found. App is running in offline mode.\");\n        });\n}\n\nexport function unregister() {\n    if (\"serviceWorker\" in navigator) {\n        navigator.serviceWorker.ready.then(registration => {\n            registration.unregister();\n        });\n    }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n// if you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}